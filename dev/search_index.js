var documenterSearchIndex = {"docs":
[{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"DocTestSetup = quote\n    using Controlz\nend","category":"page"},{"location":"tfs/#transfer-functions","page":"Transfer Functions","title":"transfer functions","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"consider the linear, time-invariant system:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"(Image: )","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"with:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"input U(s)=mathcalLu(t)\noutput Y(s)=mathcalLy(t)","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"the output for an input is characterized by a transfer function g(s)=Y(s)U(s).","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"here, mathcalLcdot is the Laplace transform that maps a function in the time domain tinmathbbR into the frequency domain sinmathbbC.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"a data structure, TransferFunction, represents a transfer function. ","category":"page"},{"location":"tfs/#constructing-a-transfer-function","page":"Transfer Functions","title":"constructing a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"for example, consider the transfer function g(s)=dfrac5s+1s^2 + 4s+5.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"constructor 1. we can construct g(s) in an intuitive way that resembles the algebraic expression:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (5 * s + 1) / (s ^ 2 + 4 * s + 5) # construction method 1\n# output\n     5.0*s + 1.0\n---------------------\n1.0*s^2 + 4.0*s + 5.0","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"constructor 2. alternatively, we can construct a TransferFunction using the coefficients associated with the powers of s in the polynomials composing the numerator and denominator, respectively, of the rational function g(s). coefficients of the highest powers of s are listed first.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = TransferFunction([5, 1], [1, 4, 5]) # construction method 2","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"note: Note\nunder the hood, s == TransferFunction([1, 0], [1]).","category":"page"},{"location":"tfs/#accessing-attributes-of-a-transfer-function","page":"Transfer Functions","title":"accessing attributes of a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"as rational functions associated with a time delay, each TransferFunction data structure has a numerator, denominator, and time_delay attribute. access as follows:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g.numerator\n# output\nPolynomial(1.0 + 5.0*s)","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g.denominator\n# output\nPolynomial(5.0 + 4.0*s + 1.0*s^2)","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g.time_delay\n# output\n0.0","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g.numerator and g.denominator are Polynomials from Polynomials.jl.","category":"page"},{"location":"tfs/#time-delays","page":"Transfer Functions","title":"time delays","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"to construct a transfer function with a time delay, such as g(s)=dfrac32s+1e^-2s...","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"θ = 2.0                              # time delay\ng = 3 / (2 * s + 1) * exp(-θ * s)    # construction method 1\ng = TransferFunction([3], [2, 1], θ) # construction method 2\n# output\n    3.0\n----------- e^(-2.0*s)\n2.0*s + 1.0","category":"page"},{"location":"tfs/#zeros,-poles,-k-factor-representation","page":"Transfer Functions","title":"zeros, poles, k-factor representation","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"we can write any transfer function g(s) in terms of its poles (p_j), zeros (z_j), k-factor (k), and time delay (theta):","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g(s)=kdfracPi_j (s-z_j)Pi_j(s-p_j)e^-theta s","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"the scalar factor k allows us to uniquely specify a transfer function in terms of its poles, zeros, and time delay. note that the k-factor is not equal to the zero-frequency gain.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"for example, consider:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g(s)=dfrac5s+1s^2 + 4s+5=5dfrac(s+15)(s+2+i)(s+2-i)","category":"page"},{"location":"tfs/#constructing-a-transfer-function-from-its-zeros,-poles-and-k-factor","page":"Transfer Functions","title":"constructing a transfer function from its zeros, poles and k-factor","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = zeros_poles_k([-1/5], [-2 + im, -2 - im], 5.0, time_delay=0.0)  # construction method 3\n# output\n     5.0*s + 1.0\n---------------------\n1.0*s^2 + 4.0*s + 5.0","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"im is the imaginary number i. see the Julia docs on complex numbers.","category":"page"},{"location":"tfs/#computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function","page":"Transfer Functions","title":"computing the poles, zeros, and k-factor of a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (5 * s + 1) / (s ^ 2 + 4 * s + 5)\nz, p, k = zeros_poles_k(g)\n# output\n([-0.2], ComplexF64[-2.0 - 1.0im, -2.0 + 1.0im], 5.0)","category":"page"},{"location":"tfs/#transfer-function-algebra","page":"Transfer Functions","title":"transfer function algebra","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"add +, subject -, multiply *, and divide / transfer functions.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g₁ = 3 / (s + 2)\ng₂ = 1 / (s + 4)\ng_product = g₁ * g₂\n# output\n         3.0\n---------------------\n1.0*s^2 + 6.0*s + 8.0","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g_sum = g₁ + g₂\n# output\n    4.0*s + 14.0\n---------------------\n1.0*s^2 + 6.0*s + 8.0","category":"page"},{"location":"tfs/#evaluate-a-transfer-function-at-a-complex-number","page":"Transfer Functions","title":"evaluate a transfer function at a complex number","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"for example, to evaluate g(s)=dfrac4s+2 at s=-2+i:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = 4 / (s + 2)\nevaluate(g, - 2 + im)\n# output\n0.0 - 4.0im","category":"page"},{"location":"tfs/#zero-frequency-gain-of-a-transfer-function","page":"Transfer Functions","title":"zero-frequency gain of a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute the zero-frequency gain of a transfer function g(s), which is g(s) evaluated at s=0, as follows:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (5 * s + 1) / (s ^ 2 + 4 * s + 5)\nzero_frequency_gain(g)\n# output\n0.2","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"the zero-frequency gain is the ratio of the steady state output value to the steady state input value (e.g., consider a step input). note that the zero-frequency gain could be infinite or zero, which is why we do not have a function to construct a transfer function from its zeros, poles, and zero-frequency gain.","category":"page"},{"location":"tfs/#poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function","page":"Transfer Functions","title":"poles, zeros, and zero-frequency gain of a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute the poles, zeros, and zero-frequency gain of a transfer function all at once as follows:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (5 * s + 5) / (s ^ 2 + 4 * s + 5)\nz, p, gain = zeros_poles_gain(g)\n# output\n([-1.0], ComplexF64[-2.0 - 1.0im, -2.0 + 1.0im], 1.0)","category":"page"},{"location":"tfs/#cancel-poles-and-zeros","page":"Transfer Functions","title":"cancel poles and zeros","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"cancel pairs of identical poles and zeros in a transfer function as follows:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"# define g(s) = s * (s+1) / ((s+3) * s * (s+1) ^ 2)\ng = TransferFunction([1, 1, 0], [1, 5, 7, 3, 0])\npole_zero_cancellation(g) # 1 / ((s+3) * (s+1))\n# output\n         1.0\n---------------------\n1.0*s^2 + 4.0*s + 3.0","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"under the hood, pole_zero_cancellation compares all pairs of poles and zeros to look for identical pairs via isapprox. after removing identical pole-zero pairs, we reconstruct the transfer function from the remaining poles and zeros–-in addition to its k-factor. we ensure that the coefficients in the resulting rational function are real.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"note: Note\npole-zero cancellation is done automatically when multiplying, dividing, adding, and subtracting transfer functions, as illustrated below.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = s * (s+1) / ((s+3) * s * (s+1) ^ 2)\n# output\n         1.0\n---------------------\n1.0*s^2 + 4.0*s + 3.0","category":"page"},{"location":"tfs/#the-order-of-a-transfer-function","page":"Transfer Functions","title":"the order of a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"we can find the apparent order of the polynomials in the numerator and denominator of the rational function comprising the transfer function:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (s + 1) / ((s + 2) * (s + 3))\nsystem_order(g)\n# output\n(1, 2)","category":"page"},{"location":"tfs/#frequency-response-of-an-open-loop-transfer-function","page":"Transfer Functions","title":"frequency response of an open-loop transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"in the closed loop below, Y_sp is the set point for the output, E is the error, and Y_m is the measurement of the output.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"(Image: )","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute the critical frequency, gain crossover frequency, gain margin, and phase margin of a closed loop control system with open-loop transfer function g_ol with gain_phase_margins. for example, consider:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g_ol(s)=dfrac2e^-s5s+1","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g_ol = 2 * exp(-s) / (5 * s + 1)\nmargins = gain_phase_margins(g_ol)\n# output\n-- gain/phase margin info--\n\tcritical frequency ω_c [rad/time]:       1.68868\n\tgain crossover frequency ω_g [rad/time]: 0.34641\n\tgain margin:                             4.25121\n\tphase margin:                            1.74798","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"access the attributes of margins via:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"margins.ω_c          # critical freq. (radians / time)\nmargins.ω_g          # gain crossover freq. (radians / time)\nmargins.gain_margin  # gain margin\nmargins.phase_margin # phase margin (radians)","category":"page"},{"location":"tfs/#special-transfer-functions","page":"Transfer Functions","title":"special transfer functions","text":"","category":"section"},{"location":"tfs/#(0,-1)-order-transfer-functions","page":"Transfer Functions","title":"(0, 1) order transfer functions","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g(s)=fracKtau s +1","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"easily construct:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"K = 2.0\nτ = 3.0\ng = first_order_system(K, τ)\n# output\n    2.0\n-----------\n3.0*s + 1.0","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute time constant:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = 10 / (6 * s + 2)\ntime_constant(g)\n# output\n3.0","category":"page"},{"location":"tfs/#(0,-2)-order-transfer-functions","page":"Transfer Functions","title":"(0, 2) order transfer functions","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g(s)=fracKtau^2 s^2 + 2tau xi s +1","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"easily construct:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"K = 1.0\nτ = 2.0\nξ = 0.1\ng = second_order_system(K, τ, ξ)\n# output\n         1.0\n---------------------\n4.0*s^2 + 0.4*s + 1.0","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute time constant, damping coefficient:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"τ = time_constant(g)\n# output\n2.0","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"ξ = damping_coefficient(g)\n# output\n0.1","category":"page"},{"location":"tfs/#closed-loop-transfer-functions","page":"Transfer Functions","title":"closed-loop transfer functions","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"to represent a closed-loop transfer function, we use a special transfer function type, ClosedLoopTransferFunction. this is only necessary when time delays are involved, but it works for when time delays are not involved as well.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"(Image: )","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"using block diagram algebra, we find the closed-loop transfer functions that relate changes in the output y to changes in the set point y_sp and to changes in the disturbance d:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g_r(s)=dfracY(s)D(s)=dfracg_d(s)1+g_c(s)g_u(s)g_m(s)","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g_s(s)=dfracY(s)Y_sp(s)=dfracg_c(s)g_u(s)1+g_c(s)g_u(s)g_m(s)","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"we construct these two closed-loop transfer functions as gr and gs as follows.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"# PI controller transfer function\npic = PIController(1.0, 2.0)\ngc = TransferFunction(pic)\n\n# process, sensor dynamics\ngu = 2 / (4 * s + 1) * exp(-0.5 * s)\ngm = 1 / (s + 1) * exp(-0.1 * s)\ngd = 6 / (6 * s + 1)\n\n# open-loop transfer function\ng_ol = gc * gu * gm\n\n# closed-loop transfer function for regulator response\ngr = ClosedLoopTransferFunction(gd, g_ol)\n# output\nclosed-loop transfer function.\n      top\n    -------\n    1 + g_ol\n\n  top =\n    6.0\n-----------\n6.0*s + 1.0\n\n  g_ol =\n       4.0*s + 2.0\n-------------------------- e^(-0.6*s)\n8.0*s^3 + 10.0*s^2 + 2.0*s","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"# closed-loop transfer function for servo response\ngs = ClosedLoopTransferFunction(gc * gu, g_ol)\n# output\nclosed-loop transfer function.\n      top\n    -------\n    1 + g_ol\n\n  top =\n  4.0*s + 2.0\n--------------- e^(-0.5*s)\n8.0*s^2 + 2.0*s\n\n  g_ol =\n       4.0*s + 2.0\n-------------------------- e^(-0.6*s)\n8.0*s^3 + 10.0*s^2 + 2.0*s","category":"page"},{"location":"tfs/#detailed-docs","page":"Transfer Functions","title":"detailed docs","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"    TransferFunction\n    ClosedLoopTransferFunction\n    zero_frequency_gain\n    zeros_poles_gain\n    zeros_poles_k\n    pole_zero_cancellation\n    evaluate\n    proper\n    strictly_proper\n    characteristic_polynomial\n    zpk_form\n    system_order\n    first_order_system\n    second_order_system\n    time_constant\n    damping_coefficient\n    gain_phase_margins","category":"page"},{"location":"tfs/#Controlz.TransferFunction","page":"Transfer Functions","title":"Controlz.TransferFunction","text":"tf = TransferFunction([1, 2], [3, 5, 8])\ntf = TransferFunction([1, 2], [3, 5, 8], 3.0)\n\nconstruct a transfer function representing a linear, time-invariant system.\n\nexample\n\nto construct the transfer function\n\nG(s) = frac4e^-22s2s+1\n\nin Julia:\n\ntf = TransferFunction([4], [2, 1], 2.2)\n# output\n    4.0\n----------- e^(-2.2*s)\n2.0*s + 1.0\n\nattributes\n\nnumerator::Polynomial{Float64, :s}: the polynomial in the numerator of the transfer function\ndenominator::Polynomial{Float64, :s}: the polynomial in the denominator of the transfer function\ntime_delay::Float64: the associated time delay\n\n\n\n\n\n","category":"type"},{"location":"tfs/#Controlz.ClosedLoopTransferFunction","page":"Transfer Functions","title":"Controlz.ClosedLoopTransferFunction","text":"a closed-loop transfer function that relates an output Y and an input U in a feedback loop.\n\nthe resulting closed-loop transfer function is:\n\n Y      top\n--- = --------\n U    1 + g_ol\n\nexample\n\ng_ol = 4 / (s + 1) * 2 / (s + 2)\ntop = 5 / (s + 4)\ng = ClosedLoopTransferFunction(top, g_ol)\n# output\nclosed-loop transfer function.\n      top\n    -------\n    1 + g_ol\n\n  top =\n    5.0\n-----------\n1.0*s + 4.0\n\n  g_ol =\n         8.0\n---------------------\n1.0*s^2 + 3.0*s + 2.0\n\nattributes\n\ntop::TransferFunction: numerator\ng_ol::TransferFunction: open-loop transfer function\n\n\n\n\n\n","category":"type"},{"location":"tfs/#Controlz.zero_frequency_gain","page":"Transfer Functions","title":"Controlz.zero_frequency_gain","text":"K = zero_frequency_gain(tf)\n\ncompute the (signed) zero frequency gain of a transfer function g(s), which is:\n\nK = lim_srightarrow 0 G(s)\n\nthe zero-frequency gain \"represents the ratio of the steady state value of the output with respect to a step input\" source\n\nexample\n\ng = 5 / (3 * s + 1)\nK = zero_frequency_gain(g)\n# output\n5.0\n\narguments\n\ntf::TransferFunction: the transfer function\n\nreturns\n\nK::Float64: the zero-frequency gain of the transfer function\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.zeros_poles_gain","page":"Transfer Functions","title":"Controlz.zeros_poles_gain","text":"z, p, gain = zeros_poles_gain(tf)\n\nCompute the zeros, poles, and zero-frequency gain of a transfer function.\n\nthe zeros are the zeros of the numerator of the transfer function.\nthe poles are the zeros of the denominator of the transfer function.\nthe zero-frequency gain is the transfer function evaluated at s=0\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.zeros_poles_k","page":"Transfer Functions","title":"Controlz.zeros_poles_k","text":"# compute the zeros, poles, and k-factor of a transfer function\nz, p, k = zeros_poles_k(tf)\n# construct a transfer function from its zeros, poles, and k-factor\ntf = zeros_poles_k(z, p, k, time_delay=0.0)\n\nthe representation of a transfer function in this context is:\n\ng(s)=kdfracPi_j (s-z_j)Pi_j (s-p_j)\n\nwhere z_j is zero j, p_j is pole j, and k is a constant factor (not equal to the zero-frequency gain) that uniquely specifies the transfer function.\n\nthe zeros are the zeros of the numerator of the transfer function.\nthe poles are the zeros of the denominator of the transfer function.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.pole_zero_cancellation","page":"Transfer Functions","title":"Controlz.pole_zero_cancellation","text":"tf = pole_zero_cancellation(tf, verbose=false, digits=8)\n\nfind (pole, zero) pairs such that pole = zero and return a new transfer function with those pairs cancelled. this is achieved by comparing the poles and zeros with isapprox, with poles and zeros rounded to  digits digits (also applies to reconstruction).\n\narguments\n\ntf::TransferFunction: the transfer function\nverbose::Bool=false: print off which poles, zeros are cancelled.\ndigits::Int: number of digits to round poles and zeros to, for (i) cancelling and (ii) reconstruction.\n\nexample\n\npole_zero_cancellation(s * (s - 1) / (s * (s + 1)))\n# output\n1.0*s - 1.0\n-----------\n1.0*s + 1.0\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.evaluate","page":"Transfer Functions","title":"Controlz.evaluate","text":"evaluate(tf, z)\n\nevaluate a TransferFunction, tf, at a particular number z (could be complex).\n\nexample\n\ntf = TransferFunction([1], [3, 1])\nevaluate(tf, 1.0)\n# output\n0.25\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.proper","page":"Transfer Functions","title":"Controlz.proper","text":"proper(tf)\n\nReturn true if transfer function tf is proper and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.strictly_proper","page":"Transfer Functions","title":"Controlz.strictly_proper","text":"strictly_proper(tf)\n\nReturn true if transfer function tf is strictly proper and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.characteristic_polynomial","page":"Transfer Functions","title":"Controlz.characteristic_polynomial","text":"p = characteristic_polynomial(g_ol)\n\nDetermine the characteristic polynomial associated with open loop transfer function g_ol.\n\nThe characteristic polynomial is 1+g_ol(s). The roots of the characteristic polynomial determine the character of the response of the closed loop system to bounded inputs.\n\nArguments\n\ng_ol::TransferFunction: open loop transfer function\n\nReturns\n\na polynomial of type Polynomial\n\nExample\n\ng_ol = 4 / (s + 3) / (s + 2) / (s + 1)\ncharacteristic_polynomial(g_ol)\n# output\nPolynomial(10.0 + 11.0*s + 6.0*s^2 + 1.0*s^3)\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.zpk_form","page":"Transfer Functions","title":"Controlz.zpk_form","text":"tf = zpk_form(tf)\n\nwrite transfer function tf in zeros, poles, k-factor form:\n\ng(s)=kdfracPi_j (s-z_j)Pi_j (s-p_j)\n\nwhere z_j is zero j, p_j is pole j, and k is a constant factor (not equal to the zero-frequency gain) that uniquely specifies the transfer function.\n\nthis is achieved by multiplying by 1.0 in a fancy way such that the highest power of s in the denominator is associated with a coefficient of 1.\n\nExample\n\ng = 8.0 / (2 * s^2 + 3 * s + 4)\ng_zpk = zpk_form(g)\n# output\n         4.0\n---------------------\n1.0*s^2 + 1.5*s + 2.0\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.system_order","page":"Transfer Functions","title":"Controlz.system_order","text":"o = system_order(tf::TransferFunction)\n\nreturn the order of the numerator and denominator of the transfer function tf.\n\nuse pole_zero_cancellation first if you wish to cancel poles and zeros that are equal before determining the order.\n\nreturns\n\no::Tuple{Int, Int}: (order of numerator, order of denominator)\n\nexamples\n\ng = 1 / (s + 1)\nsystem_order(g)\n# output \n(0, 1)\n\ng = (s + 1) / ((s + 2) * (s + 3))\nsystem_order(g)\n# output\n(1, 2)\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.first_order_system","page":"Transfer Functions","title":"Controlz.first_order_system","text":"g = first_order_system(K, τ)\n\nconstruct a first-order transfer function with gain K and time constant τ:\n\ng(s)=fracKtau s+1\n\nexample\n\nK = 1.0\nτ = 3.0\ng = first_order_system(K, τ)\n# output\n    1.0\n-----------\n3.0*s + 1.0\n\nreturns\n\ng::TransferFunction: the first order transfer function. well, (0, 1) order.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.second_order_system","page":"Transfer Functions","title":"Controlz.second_order_system","text":"g = second_order_system(K, τ, ξ)\n\nconstruct a second-order transfer function with gain K, time constant τ, and damping coefficient ξ:\n\ng(s)=fracKtau^2 s^2 + 2tau xi s +1\n\nexample\n\nK = 1.0\nτ = 2.0\nξ = 0.1\ng = second_order_system(K, τ, ξ)\n# output\n         1.0\n---------------------\n4.0*s^2 + 0.4*s + 1.0\n\nreturns\n\ng::TransferFunction: the second order transfer function. well, (0, 2) order.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.time_constant","page":"Transfer Functions","title":"Controlz.time_constant","text":"τ = time_constant(g)\n\ncompute the time constant τ of an order (0, 1) or order (0, 2) transfer function.\n\norder (0, 1) representation:\n\ng(s)=fracKtau s+1\n\norder (0, 2) representation:\n\ng(s)=fracKtau^2 s^2 + 2tau xi s +1\n\nreturns\n\nτ::Float64: the time constant.\n\nexamples\n\ng = 4 / (6 * s + 2)\ntime_constant(g)\n# output \n3.0\n\ng = 1.0 / (8 * s^2 + 0.8 * s + 2)\ntime_constant(g) \n# output\n2.0\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.damping_coefficient","page":"Transfer Functions","title":"Controlz.damping_coefficient","text":"ξ = damping_coefficient(g)\n\ncompute the damping coefficient ξ of an order (0, 2) transfer function.\n\norder (0, 2) representation:\n\ng(s)=fracKtau^2 s^2 + 2tau xi s +1\n\nreturns\n\nξ::Float64: the damping coefficient\n\nexamples\n\ng = 1.0 / (8 * s^2 + 0.8 * s + 2)\ndamping_coefficient(g)\n# output\n0.1\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.gain_phase_margins","page":"Transfer Functions","title":"Controlz.gain_phase_margins","text":"margins = gain_phase_margins(g_ol, ω_c_guess=0.001, ω_g_guess=0.001)\n\ncompute critical frequency (radians / time), gain crossover frequency (radians / time),  gain margin, and phase margin (radians) of a closed loop, given its closed loop transfer function g_ol::TransferFunction.\n\nif ωc or ωg is not found (i.e. if either are NaN), but the bode_plot clearly shows  a critical/gain crossover frequency, adjust ω_c_guess or ω_g_guess to find the root.\n\nExample\n\ng_ol = 2 * exp(-s) / (5 * s + 1)\nmargins = gain_phase_margins(g_ol)\nmargins.ω_c # critical freq. (radians / time)\nmargins.ω_g # gain crossover freq. (radians / time)\nmargins.gain_margin # gain margin\nmargins.phase_margin # phase margin (radians)\n\n\n\n\n\n","category":"function"},{"location":"controls/#Control-systems","page":"Control systems","title":"Control systems","text":"","category":"section"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"we build upon simulate to simulate feedback and feedforward control systems.","category":"page"},{"location":"controls/#P,-PI,-PID-controller-transfer-functions","page":"Control systems","title":"P, PI, PID controller transfer functions","text":"","category":"section"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"we express PID controller transfer functions in the form:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"g_c(s)=K_c left1+frac1tau_I s+tau_D s frac1tau_D alpha s + 1right","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"where alpha characterizes the derivative filter. this controller function function governs the controller output in response to the input error signal.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"To construct P, PI, or PID controllers:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"Kc = 2.0 # controller gain\npc = PController(Kc) # P-controller with given Kc\n\nτI = 1.0 # integral time constant\npic = PIController(Kc, τI) # PI-controller with given Kc, τI\n\nτD = 0.1 # derivative time constant\npidc = PIDController(Kc, τI,  τD, α=0.0) # PID-controller with given Kc, τI, τD. keyword argument is derivative filter α","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"to construct controller transfer functions g_c(s) from the P, PI, or PID controller parameters:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"pic = PIController(2.0, 1.0)\ngc = TransferFunction(pic) # (2s+2) / s","category":"page"},{"location":"controls/#servo-response-of-a-simple-control-system","page":"Control systems","title":"servo response of a simple control system","text":"","category":"section"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"with skills in block diagram algebra, we can use simulate to simulate a control system with a great degree of flexibility. as an example, we simulate the response of a simple feedback control system to a set point change.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"(Image: )","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"let's specify g_c(s) as a PI controller and g_u(s) as a first-order system. the former describes the controller output responds to the error signal. the latter describes how the process responds to inputs– here, the process input is provided by the controller.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"pic = PIController(1.0, 1.0) \ngc = TransferFunction(pic) # controller transfer function\ngu = 3 / (4 * s + 1) # process transfer function","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"via block diagram algebra, we can solve for the transfer function governing the response to set point changes.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"g_ol = gc * gu # open-loop transfer function\n\ng_servo = g_ol / (1 + g_ol) # transfer function for servo response","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"the response of the process to a unit step set point change is thus:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"Y_sp = 1 / s # unit step set point change\nY = g_servo * Y_sp # resulting output in response to our set point change","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"finally, we can find the response by inverting Y into the time domain:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"final_time = 12.0\ndata_y = simulate(Y, final_time)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"to also see the controller output, we build the error signal E and use g_c(s)=U(s)E(s) to get U.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"E = Y_sp - Y # error signal\nU = gc * E # resulting controller output\ndata_u = simulate(U, final_time) # controller output in the time domain","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"an easy way of getting the set point y_sp(t) is:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"data_y_sp = simulate(Y_sp, final_time)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"finally, we can plot y, ysp, and u against t to visualize the response of our feedback PI control system to a set point change.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"(Image: )","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"also plotted separately is the contribution to the controller output by the P- and I- components of the PI controller, obtained via:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"U_Paction = Kc * E # P-action\nU_Iaction = Kc / (τI * s) * E # I-action\n\ndata_u_Paction = simulate(U_Paction, final_time)\ndata_u_Iaction = simulate(U_Iaction, final_time)","category":"page"},{"location":"controls/#feedback-loops-with-time-delays","page":"Control systems","title":"feedback loops with time delays","text":"","category":"section"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"when time delays are involved, we must use the special implementation of a transfer function, ClosedLoopTransferFunction. we provide an example below.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"(Image: )","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"suppose the transfer functions in the block diagram are as defined below.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"# PI controller transfer function\npic = PIController(1.0, 2.0)\ngc = TransferFunction(pic)\n\n# process, sensor dynamics\ngu = 2 / (4 * s + 1) * exp(-0.5 * s)\ngm = 1 / (s + 1) * exp(-0.75 * s)\ngd = 6 / (6 * s + 1)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"we define the closed-loop transfer functions for the response to set point changes y_sp(t) and disturbances d(t) as below:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"# open-loop transfer function\ng_ol = gc * gu * gm\n\n# closed-loop transfer function for regulator response\ngr = ClosedLoopTransferFunction(gd, g_ol)\n\n# closed-loop transfer function for servo response\ngs = ClosedLoopTransferFunction(gc * gu, g_ol)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"where gr and gs represent the closed-loop transfer functions g_r(s) and g_s(s) respectively:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"g_r(s)=dfracY(s)D(s)=dfracg_d(s)1+g_c(s)g_u(s)g_m(s)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"g_s(s)=dfracY(s)Y_sp(s)=dfracg_c(s)g_u(s)1+g_c(s)g_u(s)g_m(s)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"we can then simulate responses to set point changes as:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"Ysp = 1 / s # unit step set point change\nY = gs * Ysp\ndata = simulate(Y, 50.0)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"(Image: )","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"and to disturbances as:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"D = 1 / s # unit step in disturbance variable d\nY = gr * D\ndata = simulate(Y, 50.0)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"    PController\n    PIController\n    PIDController","category":"page"},{"location":"controls/#Controlz.PController","page":"Control systems","title":"Controlz.PController","text":"pc = PController(Kc)\n\nConstruct a Proportional (P) controller by specifying the controller gain defined under the following transfer function representation:\n\ng_c(s)=K_c\n\nArguments\n\nKc::Float64: controller gain\n\nExample\n\npc = PController(1.0) # specify P controller gain\ngc = TransferFunction(pc) # construct transfer function with this P-controller gain\n\n\n\n\n\n","category":"type"},{"location":"controls/#Controlz.PIController","page":"Control systems","title":"Controlz.PIController","text":"pic = PIController(Kc, τI)\n\nConstruct a Proportional-Integral (PI) controller by specifying the controller gain and integral time constant defined under the following transfer function representation:\n\ng_c(s)=K_c left1+frac1tau_I sright\n\nArguments\n\nKc::Float64: controller gain\nτI::Float64: integral time constant\n\nExample\n\npic = PIController(1.0, 3.0) # specify PI controller params\ngc = TransferFunction(pic) # construct transfer function with these PI-controller params\n\n\n\n\n\n","category":"type"},{"location":"controls/#Controlz.PIDController","page":"Control systems","title":"Controlz.PIDController","text":"pidc = PIDController(Kc, τI, τD, α=0.0)\n\nConstruct a Proportional-Integral-Derivative (PID) controller by specifying the controller gain, integral time constant, derivative time constant, and derivative filter defined under the following transfer function representation:\n\ng_c(s)=K_c left1+frac1tau_I s+tau_D s frac1alpha tau_D s + 1right\n\nArguments\n\nKc::Float64: controller gain\nτI::Float64: integral time constant\nτD::Float64: derivative time constant\nα::Float64: derivative filter\n\nExample\n\npidc = PIDController(1.0, 3.0, 0.1) # specify PID controller params\ngc = TransferFunction(pidc) # construct transfer function with these PID-controller params\n\n\n\n\n\n","category":"type"},{"location":"viz/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"the visualizations rely on CairoMakie.jl.","category":"page"},{"location":"viz/#poles-and-zeros-of-a-transfer-function","page":"Visualization","title":"poles and zeros of a transfer function","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g = (s + 2) / (s^2 + 1/4)\nviz_poles_and_zeros(g)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/#response-of-a-system-to-an-input","page":"Visualization","title":"response of a system to an input","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g = 4 / (4 * s ^ 2 + 0.8 * s + 1)\nU = 1 / s\nY = g * U\ndata = simulate(Y, 50.0)\nviz_response(data, title=\"SO underdamped step response\")","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/#Nyquist-diagram","page":"Visualization","title":"Nyquist diagram","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g = 1 / (s^2 + s + 1)\nnyquist_diagram(g)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/#Bode-plot","page":"Visualization","title":"Bode plot","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g = 3 / (s + 1)\nbode_plot(g, log10_ω_min=-4.0, log10_ω_max=4.0, nb_pts=300)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"the range of frequencies presented is determined by log10_ω_min and log10_ω_max. the resolution of the Bode plot is determined by nb_pts.","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"see gain_phase_margins to compute the gain and phase margins and the critical and gain crossover frequencies.","category":"page"},{"location":"viz/#Root-locus-plot","page":"Visualization","title":"Root locus plot","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g_ol = 4 / (s + 3) / (s + 2) / (s + 1)\nroot_locus(g_ol)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/#modifying-the-figures","page":"Visualization","title":"modifying the figures","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"all visualization functions return a Figure object from CairoMakie.jl that can be further modified. for example:","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g_ol = 4 / (s + 3) / (s + 2) / (s + 1)\nfig = root_locus(g_ol)\nax = current_axis(fig)\nxlims!(ax, -15, 5)\nax.xlabel = \"real numbers\"","category":"page"},{"location":"viz/#cool-plot-theme","page":"Visualization","title":"cool plot theme","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"the custom plot theme can be invoked in CairoMakie.jl for other plots via:","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"using Controlz, CairoMakie\nset_theme!(cool_theme)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"more, CairoMakie.jl offers other themes here.","category":"page"},{"location":"viz/#detailed-docs","page":"Visualization","title":"detailed docs","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"    viz_response\n    viz_poles_and_zeros\n    nyquist_diagram\n    bode_plot\n    root_locus\n    mk_gif","category":"page"},{"location":"viz/#Controlz.viz_response","page":"Visualization","title":"Controlz.viz_response","text":"viz_response(data, \n             title=\"\", xlabel=\"time, t\", \n             ylabel=\"output, y*(t)\",\n             savename=nothing)\n\nplot data[:, :output] vs. data[:, :t] to visualize the response of a system to an input.  typically the data frame, data, is returned from simulate.\n\nArguments\n\ndata::DataFrame: data frame of time series data, containing a :t column for times and :output column for the outputs.\ntitle::String: title of plot\nxlabel::String: x-label\nylabel::String: y-label\nsavename::Union{Nothing, String}: filename to save as a figure in .png format.\n\nReturns\n\nCairoMakie.jl Figure object. this will display in a Pluto.jl notebook.\n\nCairoMakie.jl commands can be invoked after viz_response to make further changes to the figure panel by e.g.:\n\nfig = viz_response(data)\nax = current_axis(fig)\nax.xlabel = \"new xlabel\"\nxlims!(ax, 0, 15)\n\nExample\n\ng = 4 / (4 * s ^ 2 + 0.8 * s + 1)\nU = 1 / s\nY = g * U\ndata = simulate(Y, 50.0)\nfig = viz_response(data)\n\n\n\n\n\n","category":"function"},{"location":"viz/#Controlz.viz_poles_and_zeros","page":"Visualization","title":"Controlz.viz_poles_and_zeros","text":"viz_poles_and_zeros(g, savename=nothing, title::String=\"poles and zeros\")\n\nplot the zeros and poles of the transfer function g in the complex plane.\n\nreturns a CairoMakie.jl Figure object for further modification.\n\n\n\n\n\n","category":"function"},{"location":"viz/#Controlz.nyquist_diagram","page":"Visualization","title":"Controlz.nyquist_diagram","text":"nyquist_diagram(tf, nb_pts=500, ω_max=10.0, savename=nothing)\n\nplot the Nyquist diagram for a transfer function tf to visualize its frequency response. s=-1 is plotted as a red +. nb_pts changes the resolution. ω_max gives maximum frequency considered.\n\nreturns a CairoMakie.jl Figure object for further modification.\n\n\n\n\n\n","category":"function"},{"location":"viz/#Controlz.bode_plot","page":"Visualization","title":"Controlz.bode_plot","text":"axs = bode_plot(tf, log10_ω_min=-4.0, log10_ω_max=4.0, nb_pts=300)\n\ndraw the Bode plot of a transfer function tf to visualize its frequency response. returns the two axes of the plot for further tuning via matplotlib commands.\n\nadjust the range of frequencies that the Bode plot presents with log10_ω_min and log10_ω_max.\n\nincrease the resolution of the Bode plot with nb_pts.\n\nreturns a CairoMakie.jl Figure object for further modification.\n\n\n\n\n\n","category":"function"},{"location":"viz/#Controlz.root_locus","page":"Visualization","title":"Controlz.root_locus","text":"root_locus(g_ol, max_mag_Kc=10.0, nb_pts=500, savename=nothing, legend_pos=:rt)\n\nvisualize the root locus plot of an open-loop transfer function g_ol.\n\nArguments\n\ng_ol::TransferFunction: the open-loop transfer function of the closed loop system\nmax_mag_Kc::Float64=10.0: the maximum magnitude by which the gain of g_ol is    scaled in order to see the roots traversing the plane\nnb_pts::Int=500: the number of gains to explore. increase for higher resolution.\nlegend_pos::Symbol: Makie command for where to place legend\n\nreturns\n\na CairoMakie.jl Figure object for further modification.\n\n\n\n\n\n","category":"function"},{"location":"viz/#Controlz.mk_gif","page":"Visualization","title":"Controlz.mk_gif","text":"mk_gif(data, title=\"\", xlabel=\"time, t\", \n             ylabel=\"output, y(t)\",\n             savename=\"response\")\n\nmake a .gif of the process response. data is a data frame with two columns, :t and :output, likely returned from simulate. accepts same arguments as viz_response. ImageMagick must be installed to create the .gif. the .gif is saved as a file savename.\n\nArguments\n\ndata::DataFrame: data frame of time series data, containing a :t column for times and :output column for the outputs.\ntitle::String: title of plot\nxlabel::String: x-label\nylabel::String: y-label\nsavename::String: filename to save as a .gif. .gif extension automatically appended if not provided.\n\n\n\n\n\n","category":"function"},{"location":"sim/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"we wish to simulate the response y(t) (output) of a linear, time-invariant system, characterized by a transfer function g(s), to an input u(s). ","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"(Image: )","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"pass the output Y(s) in the frequency domain into the function simulate to invert it into the time domain to obtain y(t).  simulate returns a time series data frame (a DataFrame, see DataFrames.jl docs), with a :t column for the times and an :output column for y(t). we can then plot the time series data, interpolate the data to obtain the value of y(t) at a particular time t=Tau, etc. we provide examples below.","category":"page"},{"location":"sim/#response-of-an-underdamped-second-order-system-to-a-unit-step-input","page":"Simulation","title":"response of an underdamped second-order system to a unit step input","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"g = 4 / (4 * s ^ 2 + 0.8 * s + 1) # second order transfer function, underdamped\n\nU = 1 / s                         # unit step input\nY = g * U                         # system output\n\ndata = simulate(Y, 50.0)          # simulate until t = 50, returns DataFrame\ndata[:, :t]                       # array of times, tᵢ's\ndata[:, :output]                  # array of outputs, yᵢ's ≈ y(tᵢ)'s","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"then plot the time series via:","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"viz_response(data, title=\"SO underdamped step response\")","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"(Image: )","category":"page"},{"location":"sim/#response-of-a-first-order-plus-time-delay-system-to-a-unit-step-input","page":"Simulation","title":"response of a first-order plus time delay system to a unit step input","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"K = 2.0 # gain\nτ = 4.0 # time constant\nθ = 1.5 # time delay\ng = K * exp(-θ * s) / (τ * s + 1) # FOPTD transfer function\n\nU = 1 / s # step input\nY = g * U\n\ndata = simulate(Y, 15.0) # simulate until t = 15\n\nviz_response(data, title=\"FOPTD step response\")","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"(Image: )","category":"page"},{"location":"sim/#inverse-Laplace-transform","page":"Simulation","title":"inverse Laplace transform","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"to emphasize that our simulate function takes a function of the complex frequency s and inverts it into the time domain, consider the Laplace transform of t cos(at):","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"mathcalLt cos(at) = dfracs^2-a^2(s^2+a^2)^2","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"we can numerically invert dfracs^2-a^2(s^2+a^2)^2 as follows:","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"a = π\nU = (s^2 - a^2) / (s^2 + a^2) ^ 2\n\ndata = simulate(U, 8.0, nb_time_points=300) # simulate until t=8, use 300 time points for high resolution\n\nviz_response(data, title=\"inverting an input U(s)\", ylabel=\"u(t)\")","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"the nb_time_points argument allows us to return a time series with a higher resolution in time. if the plot of the response appears jagged, likely you need to increase nb_time_points.","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"(Image: )","category":"page"},{"location":"sim/#y(t)-at-an-arbitrary-time-\\Tau","page":"Simulation","title":"y(t) at an arbitrary time Tau","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"the simulate function returns an array of times t_i's and corresponding y_i=y(t_i)'s. if we wish to know y(t) at a particular time t=Tau, we can call interpolate to linearly interpolate the time series data.","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"for example, to obtain the output of a first-order system with time constant tau in response to a unit step input at t=tau:","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"τ = 3.45\ng = 1 / (τ * s + 1) # FO system\ndata = simulate(g / s, 10.0)  # unit step response\ny_at_τ = interpolate(data, τ) # 0.63 ≈ 1 - 1/e, as we expect","category":"page"},{"location":"sim/#under-the-hood","page":"Simulation","title":"under the hood","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"under the hood, simulate converts the system passed to it into a state space ODE (a system of ODEs) in the time domain and uses DifferentialEquations.jl (see here) to numerically solve the resulting ODE.","category":"page"},{"location":"sim/#detailed-docs","page":"Simulation","title":"detailed docs","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"    simulate\n    interpolate","category":"page"},{"location":"sim/#Controlz.simulate","page":"Simulation","title":"Controlz.simulate","text":"data = simulate(Y, final_time, nb_time_points=250) # invert Y(s)\n\nsimulate the output y(t) of an LTI system, given the Laplace transform of the output, Y(s), Y.\n\nin other words, simulate inverts an expression in the frequency domain into the time domain.\n\narguments\n\nY::Union{TransferFunction, ClosedLoopTransferFunction}: the Laplace transform of the output y(t). usually formed by g(s)U(s), where U(s) is the Laplace transform of the input and g(s) is the transfer function governing the dynamics of the system.\nfinal_time::Union{Int64, Float64}: the duration over which to simulate the output of the LTI system, starting at time zero.\nnb_time_points::Int=100: the number of time points at which to save the solution y(t).\n\ntwo time points preceding t=0 are included to illustrate that it is assumed y(t)=0 for t0.\n\nreturns\n\ndata::DataFrame: data frame containing two columns: :t for time t and :output for y(t). each row corresponds to a (t_i y(t_i)) pair. i.e., row i of the :t column is time i, t_i, and row i of the :output column is y_i=y(t_i). access the columns by data[:, :t] and data[:, :output].\n\nexamples\n\nsimulate the first order step response to a step, given the Laplace transform of the output, Y:\n\ng = 4 / (3 * s + 1)      # first-order transfer function g(s)\nU = 1 / s                # unit step input U(s)\nY = g / s                # output Y(s)\ndata = simulate(Y, 12.0) # time series data frame\ndata[:, :t]              # array of time points tᵢ\ndata[:, :output]         # array of corresponding outputs y(tᵢ)\nfirst(data, 5)           # show the first 5 rows of the data frame\n# output\n5×2 DataFrame\n Row │ t          output     \n     │ Float64    Float64    \n─────┼───────────────────────\n   1 │ -0.6       0.0\n   2 │ -1.0e-5    0.0\n   3 │  1.0e-5    1.33333e-5\n   4 │  0.123721  0.161606\n   5 │  0.247432  0.316671\n\n\n\n\n\n","category":"function"},{"location":"sim/#Controlz.interpolate","page":"Simulation","title":"Controlz.interpolate","text":"y_at_Τ = interpolate(data, Τ)\n\ninterpolate a data frame containing a time series characterizing y(t), with :t and :output columns, whose rows are (t_i y(t_i)) pairs. interpolate the data to approximate the function y(t) at a new time Τ, i.e. y(Tau).\n\nsimulate returns such a data frame, thus interpolate is useful for obtaining the solution at a particular time Τ that is not necessarily present in the :t column of data.\n\narguments\n\ndata::DataFrame: a data frame of a time series, containing a :t column for times and :output column for outputs.\nΤ::Float64: the new time at which we wish to know y. i.e. we wish to know y(Tau).\n\nReturns\n\ny_at_Τ::Float64: the value of y when t is equal to Τ, y(Tau), according to linear interpolation.\n\nexample\n\nthe unit step response of a first-order process with time constant tau is approx 63 of the final value when t=tau.\n\nτ = 3.45\ng = 1 / (τ * s + 1)           # FO system\nU = 1 / s                     # input, U(s)\nY = g * U                     # output, Y(s)\ndata = simulate(g / s, 10.0)  # output, y(t)\ny_at_τ = interpolate(data, τ) # ≈ y(τ)\n# output\n0.6320802858877126\n\n\n\n\n\n","category":"function"},{"location":"#Controlz.jl","page":"Controlz","title":"Controlz.jl","text":"","category":"section"},{"location":"","page":"Controlz","title":"Controlz","text":"Controlz.jl is a pure-Julia package to analyze and simulate process dynamics and control systems using transfer function representations.","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"e.g., the code below simulates the unit step response of a second-order, underdamped system: ","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"(Image: )","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"with","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"transfer function g(s) = dfrac44s^2 + 08s +1\ninput U(s)=mathcalLu(t)\noutput Y(s)=mathcalLy(t)=g(s)U(s)","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"where mathcalLcdot is the Laplace transform that maps a function in the time domain tinmathbbR to the frequency domain sinmathbbC.","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"using Controlz\n\ng = 4 / (4 * s ^ 2 + 0.8 * s + 1) # construct transfer function\nU = 1 / s                         # unit step input, U(s)\nY = g * U                         # system output, Y(s)\n\ndata = simulate(Y, 50.0)          # simulate until t = 50\n\nviz_response(data, title=\"SO underdamped step response\")","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"(Image: )","category":"page"},{"location":"#install-the-Controlz.jl-package-in-Julia","page":"Controlz","title":"install the Controlz.jl package in Julia","text":"","category":"section"},{"location":"","page":"Controlz","title":"Controlz","text":"Controlz.jl is an officially registered Julia package. install in the Julia REPL by typing ] to enter package mode, then add Controlz.","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"to write Controlz.jl code interactively and display the outputs, use the interactive Pluto notebook. Its automatic package manager installs Controlz.jl upon running using Controlz in a code cell.","category":"page"},{"location":"faq/#frequently-asked-questions-(FAQ)","page":"FAQ","title":"frequently asked questions (FAQ)","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"is Controlz.jl well-tested?","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"many tests are all here. run the tests by using Controlz, Pkg; Pkg.test(\"Controlz\"). that said, this package is not tested enough such that it can be used to design engineering control systems. Controlz.jl is for educational purposes only at this point.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"is Conrolz.jl free to use?","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"yes, Controlz.jl is free and open. see the associated MIT license here. the source code is on Github here.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"I'm completely new to Julia and don't know where to start.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Julia is a free and open-source, high-performance, dynamic programming language designed especially for numerical computing. see here for resources on learning Julia. I recommend the interactive Pluto Notebook as an interactive development environment for Julia.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"I found a bug.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"please post an issue here.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"may I contribute to the package?","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"absolutely! especially for fixing bugs, making documentation clearer, providing examples, etc. ","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"as for new features or significant changes, please post an issue with your plan for a pull request first so I can approve.","category":"page"}]
}
