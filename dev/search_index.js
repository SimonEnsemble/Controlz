var documenterSearchIndex = {"docs":
[{"location":"tfs/#transfer-functions","page":"Transfer Functions","title":"transfer functions","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"the response [output Y(s)] of a linear, time-invariant system to any input [U(s)] is characterized by a transfer function g(s)=Y(s)U(s).","category":"page"},{"location":"tfs/#constructing-a-transfer-function","page":"Transfer Functions","title":"constructing a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"we use a data structure, TransferFunction, to represent a transfer function. for example, consider the transfer function g(s)=dfrac5s+1s^2 + 4s+5.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"we can construct g(s) in an intuitive way that resembles the algebraic expression:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (5 * s + 1) / (s ^ 2 + 4 * s + 5) # way 1","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"alternatively, we can construct a TransferFunction using the coefficients associated with the powers of s in the polynomials composing the numerator and denominator, respectively, of g(s). The coefficients of the highest powers of s go first.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = TransferFunction([5, 1], [1, 4, 5]) # way 2","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"note that, under the hood, we defined s such that s == TransferFunction([1, 0], [1]).","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"as rational functions associated with a time delay, each TransferFunction data structure has a numerator (a polynomial in :s), denominator (a polynomial in :s), and time_delay (a real number) attribute. access these attributes as follows:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g.numerator   # 5s + 1, a `Poly`\ng.denominator # s² + 4s + 5, a `Poly`\ng.time_delay  # 0.0, a `Float64`","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g.numerator and g.denominator are Poly types from the package Polynomials.jl.","category":"page"},{"location":"tfs/#time-delays","page":"Transfer Functions","title":"time delays","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"to construct a transfer function with a time delay, such as: g(s)=dfrac32s+1e^-2s","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"θ = 2.0                              # time delay\ng = 3 / (2 * s + 1) * exp(-θ * s)    # way 1\ng = TransferFunction([3], [2, 1], θ) # way 2","category":"page"},{"location":"tfs/#zeros,-poles,-k-factor-representation","page":"Transfer Functions","title":"zeros, poles, k-factor representation","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"we can write any transfer function g(s) in terms of its poles (p_j), zeros (z_j), k-factor (k), and time delay (theta):","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g(s)=kdfracPi_j (s-z_j)Pi_j(s-p_j)e^-theta s","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"the scalar factor k allows us to uniquely specify a transfer function in terms of its poles, zeros, and time delay. note that the k-factor is not equal to the zero-frequency gain.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"for example:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g(s)=dfrac5s+1s^2 + 4s+5=5dfrac(s+15)(s+2+i)(s+2-i)","category":"page"},{"location":"tfs/#construting-a-transfer-function-from-its-zeros,-poles-and-k-factor","page":"Transfer Functions","title":"construting a transfer function from its zeros, poles and k-factor","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = zeros_poles_k([-1/5], [-2 + im, -2 - im], 5.0, time_delay=0.0)  # way 3","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"the im is the imaginary number i. see the Julia docs on complex numbers.","category":"page"},{"location":"tfs/#computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function","page":"Transfer Functions","title":"computing the poles, zeros, and k-factor of a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (5 * s + 1) / (s ^ 2 + 4 * s + 5)\nzeros_poles_k(g) # [-0.2], [-2-im, -2+im], 5","category":"page"},{"location":"tfs/#transfer-function-algebra","page":"Transfer Functions","title":"transfer function algebra","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"we can add +, subject -, multiply *, and divide / transfer functions.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g₁ = 3 / (s + 2)\ng₂ = 1 / (s + 4)\n\ng_product = g₁ * g₂ # 3 / (s^2 + 6s + 8)\n\ng_sum = g₁ + g₂     # (4s + 14) / (s^2 + 6s + 8)","category":"page"},{"location":"tfs/#evaluate-a-transfer-function-at-a-complex-number","page":"Transfer Functions","title":"evaluate a transfer function at a complex number","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"for example, to evaluate g(s)=dfrac4s+2 at s=1-i:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = 4 / (s + 2)\nevaluate(g, 2 * im) # 1 - im","category":"page"},{"location":"tfs/#zero-frequency-gain-of-a-transfer-function","page":"Transfer Functions","title":"zero-frequency gain of a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute the zero-frequency gain of a transfer function g(s), which is g(s) evaluated at s=0, as follows:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (5 * s + 1) / (s ^ 2 + 4 * s + 5)\nzero_frequency_gain(g) # 0.2","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"the zero-frequency gain is the ratio of the steady state output value to the steady state input value (e.g., consider a step input). note that the zero-frequency gain could be infinite or zero, which is why we do not have a function to construct a transfer function from its zeros, poles, and zero-frequency gain.","category":"page"},{"location":"tfs/#poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function","page":"Transfer Functions","title":"poles, zeros, and zero-frequency gain of a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute the poles, zeros, and zero-frequency gain of a transfer function all at once as follows:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (5 * s + 5) / (s ^ 2 + 4 * s + 5)\nz, p, gain = zeros_poles_gain(g)\n# z = [-1.0]\n# p = [-2-im, -2+im]\n# gain = 1.0","category":"page"},{"location":"tfs/#cancel-poles-and-zeros","page":"Transfer Functions","title":"cancel poles and zeros","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"cancel pairs of identical poles and zeros in a transfer function as follows:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = s * (s+1) / ((s+3) * s * (s+1) ^ 2)\npole_zero_cancellation(g) # 1 / ((s+3) * (s+1))","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"note that this cancellation is not done automatically.","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"under the hood, we compare all pairs of poles and zeros to look for identical pairs via isapprox. after removing identical pole-zero pairs, we reconstruct the transfer function from the remaining poles, zeros, and k-factor. we ensure that the coefficients in the resulting rational function are real.","category":"page"},{"location":"tfs/#the-order-of-a-transfer-function","page":"Transfer Functions","title":"the order of a transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"we can find the order of the polynomials in the numerator and denominator of the rational function comprising the transfer function:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (s + 1) / ((s + 2) * (s + 3))\nsystem_order(g) # (1, 2)","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"note that is only the apparent order; you may need to call pole_zero_cancellation to get the effective order:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = (s + 1) / ((s + 2) * (s + 3) * (s + 1))\nsystem_order(g) # (1, 3)\ng = pole_zero_cancellation(g)\nsystem_order(g) # (0, 2)","category":"page"},{"location":"tfs/#frequency-response-of-an-open-loop-transfer-function","page":"Transfer Functions","title":"frequency response of an open-loop transfer function","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"(Image: )","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute the critical frequency, gain crossover frequency, gain margin, and phase margin of a closed loop control system with open-loop transfer function g_ol with gain_phase_margins. for example, consider:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g_ol(s)=dfrac2e^-s5s+1","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g_ol = 2 * exp(-s) / (5 * s + 1)\n\nmargins = gain_phase_margins(g_ol)\n\nmargins.ω_c # critical freq. (radians / time)\nmargins.ω_g # gain crossover freq. (radians / time)\nmargins.gain_margin # gain margin\nmargins.phase_margin # phase margin (radians)","category":"page"},{"location":"tfs/#special-transfer-functions","page":"Transfer Functions","title":"special transfer functions","text":"","category":"section"},{"location":"tfs/#(0,-1)-order-transfer-functions","page":"Transfer Functions","title":"(0, 1) order transfer functions","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g(s)=fracKtau s +1","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"easily construct:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"K = 2.0\nτ = 3.0\ng = first_order_system(K, τ) # 2 / (3 * s + 1)","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute time constant:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"time_constant(10 / (6 * s + 2)) # 3","category":"page"},{"location":"tfs/#(0,-2)-order-transfer-functions","page":"Transfer Functions","title":"(0, 2) order transfer functions","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g(s)=fracKtau^2 s^2 + 2tau xi s +1","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"easily construct:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"K = 1.0\nτ = 2.0\nξ = 0.1\ng = second_order_system(K, τ, ξ) # 1 / (4 * s^2 + 0.4 * s + 1)","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"compute time constant, damping coefficient:","category":"page"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"g = 1.0 / (8 * s^2 + 0.8 * s + 2)\nτ = time_constant(g) # 2.0\nξ = damping_coefficient(g) # 0.1","category":"page"},{"location":"tfs/#detailed-docs","page":"Transfer Functions","title":"detailed docs","text":"","category":"section"},{"location":"tfs/","page":"Transfer Functions","title":"Transfer Functions","text":"    TransferFunction\n    zero_frequency_gain\n    zeros_poles_gain\n    zeros_poles_k\n    pole_zero_cancellation\n    evaluate\n    proper\n    strictly_proper\n    characteristic_polynomial\n    zpk_form\n    system_order\n    first_order_system\n    second_order_system\n    time_constant\n    damping_coefficient\n    gain_phase_margins","category":"page"},{"location":"tfs/#Controlz.TransferFunction","page":"Transfer Functions","title":"Controlz.TransferFunction","text":"tf = TransferFunction([1, 2], [3, 5, 8])\ntf = TransferFunction([1, 2], [3, 5, 8], 3.0)\n\nConstruct a transfer function representing a linear, time-invariant system.\n\nExample\n\nconstruct the transfer function:\n\nG(s) = frac4e^-22s2s+1\n\ntf = TransferFunction([4], [2, 1], 2.2)\n\nAttributes\n\nnumerator::Poly: the polynomial in the numerator of the transfer function\ndenominator::Poly: the polynomial in the denominator of the transfer function\ntime_delay::Float64: the associated time delay\n\n\n\n\n\n","category":"type"},{"location":"tfs/#Controlz.zero_frequency_gain","page":"Transfer Functions","title":"Controlz.zero_frequency_gain","text":"K = zero_frequency_gain(tf)\n\nCompute the (signed) zero frequency gain of a transfer function g(s), which is the value of the transfer function at s=0. \"It represents the ratio of the steady state value of the output with respect to a step input\" source\n\nArguments\n\ntf::TransferFunction: the transfer function\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.zeros_poles_gain","page":"Transfer Functions","title":"Controlz.zeros_poles_gain","text":"z, p, gain = zeros_poles_gain(tf)\n\nCompute the zeros, poles, and zero-frequency gain of a transfer function.\n\nthe zeros are the zeros of the numerator of the transfer function.\nthe poles are the zeros of the denominator of the transfer function.\nthe zero-frequency gain is the transfer function evaluated at s=0\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.zeros_poles_k","page":"Transfer Functions","title":"Controlz.zeros_poles_k","text":"# compute the zeros, poles, and k-factor of a transfer function\nz, p, k = zeros_poles_k(tf)\n# construct a transfer function from its zeros, poles, and k-factor\ntf = zeros_poles_k(z, p, k, time_delay=0.0)\n\nthe representation of a transfer function in this context is:\n\ng(s)=kdfracPi_j (s-z_j)Pi_j (s-p_j)\n\nwhere z_j is zero j, p_j is pole j, and k is a constant factor (not equal to the zero-frequency gain) that uniquely specifies the transfer function.\n\nthe zeros are the zeros of the numerator of the transfer function.\nthe poles are the zeros of the denominator of the transfer function.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.pole_zero_cancellation","page":"Transfer Functions","title":"Controlz.pole_zero_cancellation","text":"tf = pole_zero_cancellation(tf, verbose=false)\n\nFind pairs of identical poles and zeros and return a new transfer function with the appropriate poles and zeros cancelled.  This is achieved by comparing the poles and zeros with isapprox.\n\nArguments\n\ntf::TransferFunction: the transfer function\nverbose::Bool=false: print off which poles, zeros are cancelled.\n\nExample\n\ntf = s * (s - 1) / (s * (s + 1))\npole_zero_cancellation(tf) # (s-1)/(s+1)\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.evaluate","page":"Transfer Functions","title":"Controlz.evaluate","text":"evaluate(tf, z)\n\nEvaluate a TransferFunction, tf, at a particular number z.\n\nExamples\n\ntf = TransferFunction([1], [3, 1])\nevaluate(tf, 1.0) # 0.25\nevaluate(tf, 2.0 + 3.0im) # also takes imaginary numbers as input\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.proper","page":"Transfer Functions","title":"Controlz.proper","text":"proper(tf)\n\nReturn true if transfer function tf is proper and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.strictly_proper","page":"Transfer Functions","title":"Controlz.strictly_proper","text":"strictly_proper(tf)\n\nReturn true if transfer function tf is strictly proper and false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.characteristic_polynomial","page":"Transfer Functions","title":"Controlz.characteristic_polynomial","text":"p = characteristic_polynomial(g_ol)\n\nDetermine the characteristic polynomial associated with open loop transfer function g_ol.\n\nThe characteristic polynomial is 1+g_ol(s). The roots of the characteristic polynomial determine the character of the response of the closed loop system to bounded inputs.\n\nArguments\n\ng_ol::TransferFunction: open loop transfer function\n\nReturns\n\na polynomial of type Poly\n\nExample\n\ng_ol = 4 / (s + 3) / (s + 2) / (s + 1)\ncharacteristic_polynomial(g_ol) # s³ + 6s² + 11s + 10, a `Poly`\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.zpk_form","page":"Transfer Functions","title":"Controlz.zpk_form","text":"tf = zpk_form(tf)\n\nwrite transfer function tf in zeros, poles, k-factor form:\n\ng(s)=kdfracPi_j (s-z_j)Pi_j (s-p_j)\n\nwhere z_j is zero j, p_j is pole j, and k is a constant factor (not equal to the zero-frequency gain) that uniquely specifies the transfer function.\n\nthis is achieved by multiplying by 1.0 in a fancy way such that the highest power of s in the denominator is associated with a coefficient of 1.\n\nExample\n\ng = 8.0 / (2 * s^2 + 3 * s + 4)\ng_zpk = zpk_form(g) # 4 / (s^2 + 1.5 s + 2)\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.system_order","page":"Transfer Functions","title":"Controlz.system_order","text":"o = system_order(tf::TransferFunction)\n\nreturn the order of the numerator and denominator of the transfer function tf.\n\nuse pole_zero_cancellation first if you wish to cancel poles and zeros that are equal before determining the order.\n\nreturns\n\no::Tuple{Int, Int}: (order of numerator, order of denominator)\n\nexamples\n\ng = 1 / (s + 1)\nsystem_order(g) # (0, 1)\n\ng = (s + 1) / ((s + 2) * (s + 3))\nsystem_order(g) # (1, 2)\n\nwhere pole_zero_cancellation is necessary: ``julia g = (s + 1) / (s + 1) ^ 2 system_order(g) # (1, 2)\n\ng = polezerocancellation(g) # 1 / (s + 1) system_order(g) # (0, 1) ```\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.first_order_system","page":"Transfer Functions","title":"Controlz.first_order_system","text":"g = first_order_system(K, τ)\n\nconstruct a first-order transfer function with gain K and time constant τ:\n\ng(s)=fracKtau s+1\n\nexample\n\nK = 1.0\nτ = 3.0\ng = first_order_system(K, τ) # 1 / (3 * s + 1)\n\nreturns\n\ng::TransferFunction: the first order transfer function. well, (0, 1) order.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.second_order_system","page":"Transfer Functions","title":"Controlz.second_order_system","text":"g = second_order_system(K, τ, ξ)\n\nconstruct a second-order transfer function with gain K, time constant τ, and damping coefficient ξ:\n\ng(s)=fracKtau^2 s^2 + 2tau xi s +1\n\nexample\n\nK = 1.0\nτ = 2.0\nξ = 0.1\ng = second_order_system(K, τ, ξ) # 1 / (4 * s^2 + 0.4 * s + 1)\n\nreturns\n\ng::TransferFunction: the second order transfer function. well, (0, 2) order.\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.time_constant","page":"Transfer Functions","title":"Controlz.time_constant","text":"τ = time_constant(g)\n\ncompute the time constant τ of an order (0, 1) or order (0, 2) transfer function.\n\norder (0, 1) representation:\n\ng(s)=fracKtau s+1\n\norder (0, 2) representation:\n\ng(s)=fracKtau^2 s^2 + 2tau xi s +1\n\nreturns\n\nτ::Float64: the time constant.\n\nexamples\n\ng = 4 / (6 * s + 2)\ntime_constant(g) # 3.0\n\ng = 1.0 / (8 * s^2 + 0.8 * s + 2)\ntime_constant(g) # 2.0\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.damping_coefficient","page":"Transfer Functions","title":"Controlz.damping_coefficient","text":"ξ = damping_coefficient(g)\n\ncompute the damping coefficient ξ of an order (0, 2) transfer function.\n\norder (0, 2) representation:\n\ng(s)=fracKtau^2 s^2 + 2tau xi s +1\n\nreturns\n\nξ::Float64: the damping coefficient\n\nexamples\n\ng = 1.0 / (8 * s^2 + 0.8 * s + 2)\ndamping_coefficient(g) # 0.1\n\n\n\n\n\n","category":"function"},{"location":"tfs/#Controlz.gain_phase_margins","page":"Transfer Functions","title":"Controlz.gain_phase_margins","text":"margins = gain_phase_margins(g_ol, ω_c_guess=0.001, ω_g_guess=0.001)\n\ncompute critical frequency (radians / time), gain crossover frequency (radians / time),  gain margin, and phase margin (radians) of a closed loop, given its closed loop transfer function g_ol::TransferFunction.\n\nif ωc or ωg is not found (i.e. if either are NaN), but the bode_plot clearly shows  a critical/gain crossover frequency, adjust ω_c_guess or ω_g_guess to find the root.\n\nExample\n\ng_ol = 2 * exp(-s) / (5 * s + 1)\nmargins = gain_phase_margins(g_ol)\nmargins.ω_c # critical freq. (radians / time)\nmargins.ω_g # gain crossover freq. (radians / time)\nmargins.gain_margin # gain margin\nmargins.phase_margin # phase margin (radians)\n\n\n\n\n\n","category":"function"},{"location":"controls/#Control-systems","page":"Control systems","title":"Control systems","text":"","category":"section"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"we build upon simulate to simulate feedback and feedforward control systems.","category":"page"},{"location":"controls/#P,-PI,-PID-controller-transfer-functions","page":"Control systems","title":"P, PI, PID controller transfer functions","text":"","category":"section"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"we express PID controller transfer functions in the form:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"g_c(s)=K_c left1+frac1tau_I+tau_D s frac1tau_D alpha s + 1right","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"where alpha characterizes the derivative filter. this controller function function governs the controller output in response to the input error signal.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"To construct P, PI, or PID controllers:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"Kc = 2.0 # controller gain\npc = PController(Kc) # P-controller with given Kc\n\nτI = 1.0 # integral time constant\npic = PIController(Kc, τI) # PI-controller with given Kc, τI\n\nτD = 0.1 # derivative time constant\npidc = PIDController(Kc, τI,  τD, α=0.0) # PID-controller with given Kc, τI, τD. keyword argument is derivative filter α","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"to construct controller transfer functions g_c(s) from the P, PI, or PID controller parameters:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"pic = PIController(2.0, 1.0)\ngc = TransferFunction(pic) # (2s+2) / s","category":"page"},{"location":"controls/#servo-response-of-a-simple-control-system","page":"Control systems","title":"servo response of a simple control system","text":"","category":"section"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"with skills in block diagram algebra, we can use simulate to simulate a control system with a great degree of flexibility. as an example, we simulate the response of a simple feedback control system to a set point change.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"(Image: )","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"let's specify g_c(s) as a PI controller and g_p(s) as a first-order system. the former describes the controller output responds to the error signal. the latter describes how the process responds to inputs– here, the process input is provided by the controller.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"pic = PIController(1.0, 1.0) \ngc = TransferFunction(pic) # controller transfer function\ngp = 3 / (4 * s + 1) # process transfer function","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"via block diagram algebra, we can solve for the transfer function governing the response to set point changes.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"g_ol = gc * gp # open-loop transfer function\n\ng_servo = g_ol / (1 + g_ol) # transfer function for servo response","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"the response of the process to a unit step set point change is thus:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"Y_sp = 1 / s # unit step set point change\nY = g_servo * Y_sp # resulting output in response to our set point change","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"finally, we can find the response by inverting Y into the time domain:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"final_time = 12.0\ndata_y = simulate(Y, final_time)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"to also see the controller output, we build the error signal E and use g_c(s)=U(s)E(s) to get U.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"E = Y_sp - Y # error signal\nU = gc * E # resulting controller output\ndata_u = simulate(U, final_time) # controller output in the time domain","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"a cheap way of getting the set point y_sp(t) is:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"data_y_sp = simulate(Y_sp, final_time)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"finally, we can plot y, ysp, and u against t to visualize the response of our feedback PI control system to a set point change.","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"(Image: )","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"also plotted separately is the contribution to the controller output by the P- and I- components of the PI controller, obtained via:","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"U_Paction = Kc * E # P-action\nU_Iaction = Kc * τI / s * E # I-action\n\ndata_u_Paction = simulate(U_Paction, final_time)\ndata_u_Iaction = simulate(U_Iaction, final_time)","category":"page"},{"location":"controls/","page":"Control systems","title":"Control systems","text":"    PController\n    PIController\n    PIDController","category":"page"},{"location":"controls/#Controlz.PController","page":"Control systems","title":"Controlz.PController","text":"pc = PController(Kc)\n\nConstruct a Proportional (P) controller by specifying the controller gain defined under the following transfer function representation:\n\ng_c(s)=K_c\n\nArguments\n\nKc::Float64: controller gain\n\nExample\n\npc = PController(1.0) # specify P controller gain\ngc = TransferFunction(pc) # construct transfer function with this P-controller gain\n\n\n\n\n\n","category":"type"},{"location":"controls/#Controlz.PIController","page":"Control systems","title":"Controlz.PIController","text":"pic = PIController(Kc, τI)\n\nConstruct a Proportional-Integral (PI) controller by specifying the controller gain and integral time constant defined under the following transfer function representation:\n\ng_c(s)=K_c left1+frac1tau_I sright\n\nArguments\n\nKc::Float64: controller gain\nτI::Float64: integral time constant\n\nExample\n\npic = PIController(1.0, 3.0) # specify PI controller params\ngc = TransferFunction(pic) # construct transfer function with these PI-controller params\n\n\n\n\n\n","category":"type"},{"location":"controls/#Controlz.PIDController","page":"Control systems","title":"Controlz.PIDController","text":"pidc = PIDController(Kc, τI, τD, α=0.0)\n\nConstruct a Proportional-Integral-Derivative (PID) controller by specifying the controller gain, integral time constant, derivative time constant, and derivative filter defined under the following transfer function representation:\n\ng_c(s)=K_c left1+frac1tau_I s+tau_D s frac1alpha tau_D s + 1right\n\nArguments\n\nKc::Float64: controller gain\nτI::Float64: integral time constant\nτD::Float64: derivative time constant\nα::Float64: derivative filter\n\nExample\n\npidc = PIDController(1.0, 3.0, 0.1) # specify PID controller params\ngc = TransferFunction(pidc) # construct transfer function with these PID-controller params\n\n\n\n\n\n","category":"type"},{"location":"viz/#Visualization","page":"Visualization","title":"Visualization","text":"","category":"section"},{"location":"viz/#poles-and-zeros-of-a-transfer-function","page":"Visualization","title":"poles and zeros of a transfer function","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g = (s + 2) / (s^2 + 1/4)\nviz_poles_and_zeros(g)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/#response-of-a-system-to-an-input","page":"Visualization","title":"response of a system to an input","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g = 4 / (4 * s ^ 2 + 0.8 * s + 1)\nU = 1 / s\nY = g * U\ndata = simulate(Y, (0.0, 50.0))\nviz_response(data, plot_title=\"SO underdamped step response\")","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/#Nyquist-diagram","page":"Visualization","title":"Nyquist diagram","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g = 1 / (s^2 + s + 1)\nnyquist_diagram(g)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/#Bode-plot","page":"Visualization","title":"Bode plot","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g = 3 / (s + 1)\nbode_plot(g, log10_ω_min=-4.0, log10_ω_max=4.0, nb_pts=300)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"the range of frequencies presented is determined by log10_ω_min and log10_ω_max. the resolution of the Bode plot is determined by nb_pts.","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"see gain_phase_margins to compute the gain and phase margins and the critical and gain crossover frequencies.","category":"page"},{"location":"viz/#Root-locus-plot","page":"Visualization","title":"Root locus plot","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"g_ol = 4 / (s + 3) / (s + 2) / (s + 1)\nroot_locus(g_ol)","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"(Image: )","category":"page"},{"location":"viz/#hipster-plot-theme","page":"Visualization","title":"hipster plot theme","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"invoke the hipster plot theme used to make plots for this documentation by:","category":"page"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"using PyPlot\nPyPlot.matplotlib.style.use(\"https://raw.githubusercontent.com/SimonEnsemble/Controlz.jl/master/src/hipster.mplstyle\")","category":"page"},{"location":"viz/#detailed-docs","page":"Visualization","title":"detailed docs","text":"","category":"section"},{"location":"viz/","page":"Visualization","title":"Visualization","text":"    viz_poles_and_zeros\n    viz_response\n    nyquist_diagram\n    bode_plot\n    root_locus\n    mk_gif","category":"page"},{"location":"viz/#Controlz.viz_poles_and_zeros","page":"Visualization","title":"Controlz.viz_poles_and_zeros","text":"viz_poles_and_zeros(tf)\n\nplot the zeros and poles of the transfer function tf in the complex plane.\n\n\n\n\n\n","category":"function"},{"location":"viz/#Controlz.nyquist_diagram","page":"Visualization","title":"Controlz.nyquist_diagram","text":"nyquist_diagram(tf, nb_pts=500, ω_max=10.0)\n\nplot the Nyquist diagram for a transfer function tf to visualize its frequency response. s=-1 is plotted as a red +. nb_pts changes the resolution. ω_max gives maximum frequency considered.\n\n\n\n\n\n","category":"function"},{"location":"viz/#Controlz.bode_plot","page":"Visualization","title":"Controlz.bode_plot","text":"axs = bode_plot(tf, log10_ω_min=-4.0, log10_ω_max=4.0, nb_pts=300)\n\ndraw the Bode plot of a transfer function tf to visualize its frequency response. returns the two axes of the plot for further tuning via matplotlib commands.\n\nadjust the range of frequencies that the Bode plot presents with log10_ω_min and log10_ω_max. increase the resolution of the Bode plot with nb_pts.\n\n\n\n\n\n","category":"function"},{"location":"viz/#Controlz.root_locus","page":"Visualization","title":"Controlz.root_locus","text":"root_locus(g_ol, max_mag_Kc=10.0, nb_pts=500)\n\nvisualize the root locus plot of an open-loop transfer function g_ol.\n\nArguments\n\ng_ol::TransferFunction: the open-loop transfer function of the closed loop system\nmax_mag_Kc::Float64=10.0: the maximum magnitude by which the gain of g_ol is    scaled in order to see the roots traversing the plane\nnb_pts::Int=500: the number of gains to explore. increase for higher resolution.\n\n\n\n\n\n","category":"function"},{"location":"viz/#Controlz.mk_gif","page":"Visualization","title":"Controlz.mk_gif","text":"mk_gif(data, plot_title=\"\", plot_xlabel=\"time, t\", \n             plot_ylabel=\"output, y(t)\",\n             savename=\"response\")\n\nmake a .gif of the process response. data is a data frame with two columns, :t and :output, likely returned from simulate. accepts same arguments as viz_response. ImageMagick must be installed to create the .gif. the .gif is saved as a file savename.\n\nArguments\n\ndata::DataFrame: data frame of time series data, containing a :t column for times and :output column for the outputs.\nplot_title::Union{String, LaTeXString}: title of plot\nplot_xlabel::Union{String, LaTeXString}: x-label\nplot_ylabel::Union{String, LaTeXString}: y-label\nsavename::String: filename to save as a .gif. .gif extension automatically appended if not provided.\n\n\n\n\n\n","category":"function"},{"location":"sim/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"we wish to simulate the response y(t) (output) of a linear, time-invariant system, characterized by a transfer function g(s), to an input u(s). ","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"(Image: )","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"pass the output Y(s) in the frequency domain into the function simulate to invert it into the time domain to obtain y(t).  simulate returns a time series data frame (a DataFrame, see DataFrames.jl docs), with a :t column for the times and an :output column for y(t). we can then plot the time series data, interpolate the data to obtain the value of y(t) at a particular time t=Tau, etc. we provide examples below.","category":"page"},{"location":"sim/#response-of-an-underdamped-second-order-system-to-a-unit-step-input","page":"Simulation","title":"response of an underdamped second-order system to a unit step input","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"g = 4 / (4 * s ^ 2 + 0.8 * s + 1) # second order transfer function, underdamped\n\nU = 1 / s # unit step input\nY = g * U # system output\n\ndata = simulate(Y, 50.0) # simulate until t = 50, returns DataFrame\ndata[:, :t]      # array of times, tᵢ's\ndata[:, :output] # array of outputs, yᵢ's ≈ y(tᵢ)'s","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"we can then plot the time series via:","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"viz_response(data, plot_title=\"SO underdamped step response\")","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"(Image: )","category":"page"},{"location":"sim/#response-of-a-first-order-plus-time-delay-system-to-a-unit-step-input","page":"Simulation","title":"response of a first-order plus time delay system to a unit step input","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"K = 2.0 # gain\nτ = 4.0 # time constant\nθ = 1.5 # time delay\ng = K * exp(-θ * s) / (τ * s + 1) # FOPTD transfer function\n\nU = 1 / s # step input\nY = g * U\n\ndata = simulate(Y, 15.0) # simulate until t = 15\n\nviz_response(data, plot_title=\"FOPTD step response\")","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"(Image: )","category":"page"},{"location":"sim/#inverse-Laplace-transform","page":"Simulation","title":"inverse Laplace transform","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"to emphasize that our simulate function takes a function of the complex frequency s and inverts it into the time domain, consider the Laplace transform of t cos(at):","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"mathcalLt cos(at) = dfracs^2-a^2(s^2+a^2)^2","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"we can numerically invert dfracs^2-a^2(s^2+a^2)^2 as follows:","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"a = π\nU = (s^2 - a^2) / (s^2 + a^2) ^ 2\n\ndata = simulate(U, 8.0, nb_time_points=300) # simulate until t=8, use 300 time points for high resolution\n\nviz_response(data, plot_title=L\"inverting an input $U(s)$\", plot_ylabel=L\"$u(t)$\")","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"the nb_time_points argument allows us to return a time series with a higher resolution in time. if the plot of the response appears jagged, likely you need to increase nb_time_points.","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"(Image: )","category":"page"},{"location":"sim/#y(t)-at-an-arbitrary-time-\\Tau","page":"Simulation","title":"y(t) at an arbitrary time Tau","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"the simulate function returns an array of times t_i's and corresponding y_i=y(t_i)'s. if we wish to know y(t) at a particular time t=Tau, we can call interpolate to linearly interpolate the time series data.","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"for example, to obtain the output of a first-order system with time constant tau in response to a unit step input at t=tau:","category":"page"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"τ = 3.45\ng = 1 / (τ * s + 1) # FO system\ndata = simulate(g / s, 10.0)  # unit step response\ny_at_τ = interpolate(data, τ) # 0.63 ≈ 1 - 1/e, as we expect","category":"page"},{"location":"sim/#under-the-hood","page":"Simulation","title":"under the hood","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"under the hood, simulate converts the system passed to it into a state space ODE (a system of ODEs) in the time domain and uses DifferentialEquations.jl (see here) to numerically solve the resulting ODE.","category":"page"},{"location":"sim/#detailed-docs","page":"Simulation","title":"detailed docs","text":"","category":"section"},{"location":"sim/","page":"Simulation","title":"Simulation","text":"    simulate\n    interpolate\n    viz_response","category":"page"},{"location":"sim/#Controlz.simulate","page":"Simulation","title":"Controlz.simulate","text":"data = simulate(Y, final_time, nb_time_points=100) # invert Y(s)\n\nsimulate the output y(t) of an LTI system, given the Laplace transform of the output, Y(s), Y.\n\nin other words, simulate inverts an expression in the frequency domain into the time domain.\n\narguments\n\nY::TransferFunction: the Laplace transform of the output y(t). usually formed by g(s)U(s), where U(s) is the Laplace transform of the input and g(s) is the transfer function governing the dynamics of the system.\nfinal_time::Tuple{Float64, Float64}: the duration over which to simulate the output of the LTI system, starting at time zero.\nnb_time_points::Int=100: the number of time points at which to save the solution y(t)\n\ntwo time points preceding t=0 are included to illustrate that it is assumed y(t)=0 for t0.\n\nreturns\n\ndata::DataFrame: data frame containing two columns: :t for time t and :output for y(t). each row corresponds to a (t_i y(t_i)) pair. i.e., row i of the :t column is time i, t_i, and row i of the :output column is y_i=y(t_i). access the columns by data[:, :t] and data[:, :output].\n\nexample\n\nsimulate the first order step response to a step, given the Laplace transform of the output, Y:\n\ng = 4 / (3 * s + 1)      # first-order transfer function g(s)\nU = 1 / s                # unit step input U(s)\nY = g / s                # output Y(s)\ndata = simulate(Y, 12.0) # time series data frame\ndata[:, :t]              # array of time points tᵢ\ndata[:, :output]         # array of corresponding outputs y(tᵢ)\n\n\n\n\n\n","category":"function"},{"location":"sim/#Controlz.interpolate","page":"Simulation","title":"Controlz.interpolate","text":"y_at_Τ = interpolate(data, Τ)\n\ninterpolate a data frame containing a time series characterizing y(t), with :t and :output columns, whose rows are (t_i y(t_i)) pairs. interpolate the data to approximate the function y(t) at a new time Τ, i.e. y(Tau).\n\nsimulate returns such a data frame, thus interpolate is useful for obtaining the solution at a particular time Τ that is not necessarily present in the :t column of data.\n\narguments\n\ndata::DataFrame: a data frame of a time series, containing a :t column for times and :output column for outputs.\nΤ::Float64: the new time at which we wish to know y. i.e. we wish to know y(Tau).\n\nReturns\n\ny_at_Τ::Float64: the value of y when t is equal to Τ, y(Tau), according to linear interpolation.\n\nexample\n\nthe unit step response of a first-order process with time constant tau is approx 63 of the final value when t=tau.\n\nτ = 3.45\ng = 1 / (τ * s + 1)           # FO system\ndata = simulate(g / s, 10.0)  # unit step response\ny_at_τ = interpolate(data, τ) # 0.63\n\n\n\n\n\n","category":"function"},{"location":"sim/#Controlz.viz_response","page":"Simulation","title":"Controlz.viz_response","text":"viz_response(data, \n             plot_title=\"\", plot_xlabel=\"time, t\", \n             plot_ylabel=\"output, y(t)\",\n             savename=nothing)\n\nplot data[:, :output] vs. data[:, :t] to visualize the response of a system to an input.  typically the data frame, data, is returned from simulate.\n\nnote that PyPlot.jl (matplotlib) commands can be invoked after viz_response to make further changes to the figure panel. e.g. xlim([0, 1]) can be applied after viz_response.\n\nArguments\n\ndata::DataFrame: data frame of time series data, containing a :t column for times and :output column for the outputs.\nplot_title::Union{String, LaTeXString}: title of plot\nplot_xlabel::Union{String, LaTeXString}: x-label\nplot_ylabel::Union{String, LaTeXString}: y-label\nsavename::Union{Nothing, String}: filename to save as a figure in .png format (dpi 250).\n\nExample\n\ng = 4 / (4 * s ^ 2 + 0.8 * s + 1)\nu = 1 / s\ndata = simulate(g * u, (0.0, 50.0))\nviz_response(data)\n\n\n\n\n\n","category":"function"},{"location":"#Controlz.jl","page":"Controlz","title":"Controlz.jl","text":"","category":"section"},{"location":"","page":"Controlz","title":"Controlz","text":"Controlz.jl is a Julia package to explore concepts in the simulation of process dynamics and control of linear, time-invariant (LTI) systems using transfer function representations.","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"For example, to simulate the unit step response of a second-order, underdamped system characterized by the transfer function","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"g(s) = dfrac44s^2 + 08s +1","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"the output Y(s) follows from g(s)U(s), where U(s) is the input.","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"using Controlz\n\ng = 4 / (4 * s ^ 2 + 0.8 * s + 1) # construct transfer function\nU = 1 / s # unit step input, U(s)\nY = g * U # system output, Y(s)\n\ndata = simulate(Y, 50.0) # simulate until t = 50\n\nviz_response(data, plot_title=\"SO underdamped step response\")","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"(Image: )","category":"page"},{"location":"#install-the-Controlz.jl-package-in-Julia","page":"Controlz","title":"install the Controlz.jl package in Julia","text":"","category":"section"},{"location":"","page":"Controlz","title":"Controlz","text":"in the Julia REPL: go into package mode by typing ]. Then add Controlz#master. Then Backspace to exit package mode.\nin a Jupyter or Pluto Notebook: using Pkg; Pkg.add(\"Controlz#master\"). (this way also works in the REPL)","category":"page"},{"location":"","page":"Controlz","title":"Controlz","text":"for visualization, Controlz.jl relies on PyPlot.jl, a Julia interface to matplotlib in Python. see here if you have trouble installing PyPlot.jl.","category":"page"},{"location":"faq/#frequently-asked-questions-(FAQ)","page":"FAQ","title":"frequently asked questions (FAQ)","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"is Controlz.jl well-tested?","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"many tests are all here. run the tests by using Controlz, Pkg; Pkg.test(\"Controlz\"). that said, this package is not tested enough such that it can be used to design engineering control systems. Controlz.jl is for educational purposes only at this point.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"is Conrolz.jl free to use?","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"yes, Controlz.jl is free and open. see the associated MIT license here. the source code is on Github here.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"I'm completely new to Julia and don't know where to start.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Julia is a free and open-source, high-performance, dynamic programming language designed especially for numerical computing. See here for resources on learning Julia. I recommend Jupyter Lab or Jupyter Notebook as an interactive development environment for Julia.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"I found a bug.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"please post an issue here.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"may I contribute to the package?","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"absolutely! especially for fixing bugs, making documentation clearer, providing examples, etc. as for new features, please post an issue with your plan for a pull request first.","category":"page"}]
}
