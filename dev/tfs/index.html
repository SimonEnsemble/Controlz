<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transfer Functions · Controlz.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Controlz.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Controlz.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Controlz</a></li><li class="is-active"><a class="tocitem" href>Transfer Functions</a><ul class="internal"><li><a class="tocitem" href="#constructing-a-transfer-function"><span>constructing a transfer function</span></a></li><li><a class="tocitem" href="#time-delays"><span>time delays</span></a></li><li><a class="tocitem" href="#zeros,-poles,-k-factor-representation"><span>zeros, poles, k-factor representation</span></a></li><li><a class="tocitem" href="#transfer-function-algebra"><span>transfer function algebra</span></a></li><li><a class="tocitem" href="#evaluate-a-transfer-function-at-a-complex-number"><span>evaluate a transfer function at a complex number</span></a></li><li><a class="tocitem" href="#zero-frequency-gain-of-a-transfer-function"><span>zero-frequency gain of a transfer function</span></a></li><li><a class="tocitem" href="#poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function"><span>poles, zeros, and zero-frequency gain of a transfer function</span></a></li><li><a class="tocitem" href="#cancel-poles-and-zeros"><span>cancel poles and zeros</span></a></li><li><a class="tocitem" href="#the-order-of-a-transfer-function"><span>the order of a transfer function</span></a></li><li><a class="tocitem" href="#frequency-response-of-an-open-loop-transfer-function"><span>frequency response of an open-loop transfer function</span></a></li><li><a class="tocitem" href="#special-transfer-functions"><span>special transfer functions</span></a></li><li><a class="tocitem" href="#closed-loop-transfer-functions"><span>closed-loop transfer functions</span></a></li><li><a class="tocitem" href="#detailed-docs"><span>detailed docs</span></a></li></ul></li><li><a class="tocitem" href="../sim/">Simulation</a></li><li><a class="tocitem" href="../viz/">Visualization</a></li><li><a class="tocitem" href="../controls/">Control systems</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Transfer Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Transfer Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SimonEnsemble/Controlz.jl/blob/master/docs/src/tfs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="transfer-functions"><a class="docs-heading-anchor" href="#transfer-functions">transfer functions</a><a id="transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#transfer-functions" title="Permalink"></a></h1><p>the response [output <span>$Y(s)$</span>] of a linear, time-invariant system to any input [<span>$U(s)$</span>] is characterized by a transfer function <span>$g(s)=Y(s)/U(s)$</span>.</p><h2 id="constructing-a-transfer-function"><a class="docs-heading-anchor" href="#constructing-a-transfer-function">constructing a transfer function</a><a id="constructing-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#constructing-a-transfer-function" title="Permalink"></a></h2><p>we use a data structure, <code>TransferFunction</code>, to represent a transfer function. for example, consider the transfer function <span>$g(s)=\dfrac{5s+1}{s^2 + 4s+5}$</span>.</p><p>we can construct <span>$g(s)$</span> in an intuitive way that resembles the algebraic expression:</p><pre><code class="language-julia">g = (5 * s + 1) / (s ^ 2 + 4 * s + 5) # way 1</code></pre><p>alternatively, we can construct a <code>TransferFunction</code> using the coefficients associated with the powers of <span>$s$</span> in the polynomials composing the numerator and denominator, respectively, of <span>$g(s)$</span>. The coefficients of the highest powers of <span>$s$</span> go first.</p><pre><code class="language-julia">g = TransferFunction([5, 1], [1, 4, 5]) # way 2</code></pre><p>note that, under the hood, we defined <code>s</code> such that <code>s == TransferFunction([1, 0], [1])</code>.</p><p>as rational functions associated with a time delay, each <code>TransferFunction</code> data structure has a <code>numerator</code> (a polynomial in <code>:s</code>), <code>denominator</code> (a polynomial in <code>:s</code>), and <code>time_delay</code> (a real number) attribute. access these attributes as follows:</p><pre><code class="language-julia">g.numerator   # 5s + 1, a `Poly`
g.denominator # s² + 4s + 5, a `Poly`
g.time_delay  # 0.0, a `Float64`</code></pre><p><code>g.numerator</code> and <code>g.denominator</code> are <code>Poly</code> types from the package <a href="https://github.com/JuliaMath/Polynomials.jl">Polynomials.jl</a>.</p><h2 id="time-delays"><a class="docs-heading-anchor" href="#time-delays">time delays</a><a id="time-delays-1"></a><a class="docs-heading-anchor-permalink" href="#time-delays" title="Permalink"></a></h2><p>to construct a transfer function with a time delay, such as: <span>$g(s)=\dfrac{3}{2s+1}e^{-2s}$</span></p><pre><code class="language-julia">θ = 2.0                              # time delay
g = 3 / (2 * s + 1) * exp(-θ * s)    # way 1
g = TransferFunction([3], [2, 1], θ) # way 2</code></pre><h2 id="zeros,-poles,-k-factor-representation"><a class="docs-heading-anchor" href="#zeros,-poles,-k-factor-representation">zeros, poles, k-factor representation</a><a id="zeros,-poles,-k-factor-representation-1"></a><a class="docs-heading-anchor-permalink" href="#zeros,-poles,-k-factor-representation" title="Permalink"></a></h2><p>we can write any transfer function <span>$g(s)$</span> in terms of its poles (<span>$p_j$</span>), zeros (<span>$z_j$</span>), k-factor (<span>$k$</span>), and time delay (<span>$\theta$</span>):</p><p class="math-container">\[g(s)=k\dfrac{\Pi_j (s-z_j)}{\Pi_j(s-p_j)}e^{-\theta s}\]</p><p>the scalar factor <span>$k$</span> allows us to uniquely specify a transfer function in terms of its poles, zeros, and time delay. note that the <span>$k$</span>-factor is not equal to the zero-frequency gain.</p><p>for example:</p><p class="math-container">\[g(s)=\dfrac{5s+1}{s^2 + 4s+5}=5\dfrac{(s+1/5)}{(s+2+i)(s+2-i)}\]</p><h4 id="construting-a-transfer-function-from-its-zeros,-poles-and-k-factor"><a class="docs-heading-anchor" href="#construting-a-transfer-function-from-its-zeros,-poles-and-k-factor">construting a transfer function from its zeros, poles and k-factor</a><a id="construting-a-transfer-function-from-its-zeros,-poles-and-k-factor-1"></a><a class="docs-heading-anchor-permalink" href="#construting-a-transfer-function-from-its-zeros,-poles-and-k-factor" title="Permalink"></a></h4><pre><code class="language-julia">g = zeros_poles_k([-1/5], [-2 + im, -2 - im], 5.0, time_delay=0.0)  # way 3</code></pre><p>the <code>im</code> is the imaginary number <span>$i$</span>. see the <a href="https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/">Julia docs on complex numbers</a>.</p><h4 id="computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function"><a class="docs-heading-anchor" href="#computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function">computing the poles, zeros, and k-factor of a transfer function</a><a id="computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function" title="Permalink"></a></h4><pre><code class="language-none">g = (5 * s + 1) / (s ^ 2 + 4 * s + 5)
zeros_poles_k(g) # [-0.2], [-2-im, -2+im], 5</code></pre><h2 id="transfer-function-algebra"><a class="docs-heading-anchor" href="#transfer-function-algebra">transfer function algebra</a><a id="transfer-function-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#transfer-function-algebra" title="Permalink"></a></h2><p>we can add <code>+</code>, subject <code>-</code>, multiply <code>*</code>, and divide <code>/</code> transfer functions.</p><pre><code class="language-julia">g₁ = 3 / (s + 2)
g₂ = 1 / (s + 4)

g_product = g₁ * g₂ # 3 / (s^2 + 6s + 8)

g_sum = g₁ + g₂     # (4s + 14) / (s^2 + 6s + 8)</code></pre><h2 id="evaluate-a-transfer-function-at-a-complex-number"><a class="docs-heading-anchor" href="#evaluate-a-transfer-function-at-a-complex-number">evaluate a transfer function at a complex number</a><a id="evaluate-a-transfer-function-at-a-complex-number-1"></a><a class="docs-heading-anchor-permalink" href="#evaluate-a-transfer-function-at-a-complex-number" title="Permalink"></a></h2><p>for example, to evaluate <span>$g(s)=\dfrac{4}{s+2}$</span> at <span>$s=1-i$</span>:</p><pre><code class="language-julia">g = 4 / (s + 2)
evaluate(g, 2 * im) # 1 - im</code></pre><h2 id="zero-frequency-gain-of-a-transfer-function"><a class="docs-heading-anchor" href="#zero-frequency-gain-of-a-transfer-function">zero-frequency gain of a transfer function</a><a id="zero-frequency-gain-of-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#zero-frequency-gain-of-a-transfer-function" title="Permalink"></a></h2><p>compute the zero-frequency gain of a transfer function <span>$g(s)$</span>, which is <span>$g(s)$</span> evaluated at <span>$s=0$</span>, as follows:</p><pre><code class="language-julia">g = (5 * s + 1) / (s ^ 2 + 4 * s + 5)
zero_frequency_gain(g) # 0.2</code></pre><p>the zero-frequency gain is the ratio of the steady state output value to the steady state input value (e.g., consider a step input). note that the zero-frequency gain could be infinite or zero, which is why we do not have a function to construct a transfer function from its zeros, poles, and <em>zero-frequency gain</em>.</p><h2 id="poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function"><a class="docs-heading-anchor" href="#poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function">poles, zeros, and zero-frequency gain of a transfer function</a><a id="poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function" title="Permalink"></a></h2><p>compute the poles, zeros, and zero-frequency gain of a transfer function all at once as follows:</p><pre><code class="language-julia">g = (5 * s + 5) / (s ^ 2 + 4 * s + 5)
z, p, gain = zeros_poles_gain(g)
# z = [-1.0]
# p = [-2-im, -2+im]
# gain = 1.0</code></pre><h2 id="cancel-poles-and-zeros"><a class="docs-heading-anchor" href="#cancel-poles-and-zeros">cancel poles and zeros</a><a id="cancel-poles-and-zeros-1"></a><a class="docs-heading-anchor-permalink" href="#cancel-poles-and-zeros" title="Permalink"></a></h2><p>cancel pairs of identical poles and zeros in a transfer function as follows:</p><pre><code class="language-julia">pole_zero_cancellation(s * (s+1) / ((s+3) * s * (s+1) ^ 2)) # 1 / ((s+3) * (s+1))</code></pre><p>note that this cancellation is done automatically when multiplying, dividing, adding, and subtracting transfer functions.</p><p>under the hood, we compare all pairs of poles and zeros to look for identical pairs via <code>isapprox</code>. after removing identical pole-zero pairs, we reconstruct the transfer function from the remaining poles, zeros, and k-factor. we ensure that the coefficients in the resulting rational function are real.</p><h2 id="the-order-of-a-transfer-function"><a class="docs-heading-anchor" href="#the-order-of-a-transfer-function">the order of a transfer function</a><a id="the-order-of-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#the-order-of-a-transfer-function" title="Permalink"></a></h2><p>we can find the order of the polynomials in the numerator and denominator of the rational function comprising the transfer function:</p><pre><code class="language-julia">g = (s + 1) / ((s + 2) * (s + 3))
system_order(g) # (1, 2)</code></pre><p>note that is only the <em>apparent</em> order; you may need to call <code>pole_zero_cancellation</code> to get the effective order:</p><pre><code class="language-julia">g = (s + 1) / ((s + 2) * (s + 3) * (s + 1))
system_order(g) # (1, 3)
g = pole_zero_cancellation(g)
system_order(g) # (0, 2)</code></pre><h2 id="frequency-response-of-an-open-loop-transfer-function"><a class="docs-heading-anchor" href="#frequency-response-of-an-open-loop-transfer-function">frequency response of an open-loop transfer function</a><a id="frequency-response-of-an-open-loop-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#frequency-response-of-an-open-loop-transfer-function" title="Permalink"></a></h2><p><img src="../g_ol.png" alt/></p><p>compute the critical frequency, gain crossover frequency, gain margin, and phase margin of a closed loop control system with open-loop transfer function <code>g_ol</code> with <code>gain_phase_margins</code>. for example, consider:</p><p class="math-container">\[g_{ol}(s)=\dfrac{2e^{-s}}{5s+1}\]</p><pre><code class="language-julia">g_ol = 2 * exp(-s) / (5 * s + 1)

margins = gain_phase_margins(g_ol)

margins.ω_c # critical freq. (radians / time)
margins.ω_g # gain crossover freq. (radians / time)
margins.gain_margin # gain margin
margins.phase_margin # phase margin (radians)</code></pre><h2 id="special-transfer-functions"><a class="docs-heading-anchor" href="#special-transfer-functions">special transfer functions</a><a id="special-transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#special-transfer-functions" title="Permalink"></a></h2><h3 id="(0,-1)-order-transfer-functions"><a class="docs-heading-anchor" href="#(0,-1)-order-transfer-functions">(0, 1) order transfer functions</a><a id="(0,-1)-order-transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#(0,-1)-order-transfer-functions" title="Permalink"></a></h3><p class="math-container">\[g(s)=\frac{K}{\tau s +1}\]</p><p>easily construct:</p><pre><code class="language-julia">K = 2.0
τ = 3.0
g = first_order_system(K, τ) # 2 / (3 * s + 1)</code></pre><p>compute time constant:</p><pre><code class="language-none">time_constant(10 / (6 * s + 2)) # 3</code></pre><h3 id="(0,-2)-order-transfer-functions"><a class="docs-heading-anchor" href="#(0,-2)-order-transfer-functions">(0, 2) order transfer functions</a><a id="(0,-2)-order-transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#(0,-2)-order-transfer-functions" title="Permalink"></a></h3><p class="math-container">\[g(s)=\frac{K}{\tau^2 s^2 + 2\tau \xi s +1}\]</p><p>easily construct:</p><pre><code class="language-julia">K = 1.0
τ = 2.0
ξ = 0.1
g = second_order_system(K, τ, ξ) # 1 / (4 * s^2 + 0.4 * s + 1)</code></pre><p>compute time constant, damping coefficient:</p><pre><code class="language-julia">g = 1.0 / (8 * s^2 + 0.8 * s + 2)
τ = time_constant(g) # 2.0
ξ = damping_coefficient(g) # 0.1</code></pre><h2 id="closed-loop-transfer-functions"><a class="docs-heading-anchor" href="#closed-loop-transfer-functions">closed-loop transfer functions</a><a id="closed-loop-transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#closed-loop-transfer-functions" title="Permalink"></a></h2><p>to represent a closed-loop transfer function, we use a special transfer function type, <code>ClosedLoopTransferFunction</code>. this is only necessary when time delays are involved, but it works for when time delays are <em>not</em> involved as well.</p><p><img src="../assets/full_feedback_control_system.png" alt/></p><p>using block diagram algebra, we find the closed-loop transfer functions that relate changes in the output <span>$y$</span> to changes in the set point <span>$y_{sp}$</span> and to changes in the disturbance <span>$d$</span>:</p><p class="math-container">\[g_r(s)=\dfrac{Y(s)}{D(s)}=\dfrac{g_d(s)}{1+g_c(s)g_u(s)g_m(s)}\]</p><p class="math-container">\[g_s(s)=\dfrac{Y(s)}{Y_{sp}(s)}=\dfrac{g_c(s)g_u(s)g_m(s)}{1+g_c(s)g_u(s)g_m(s)}\]</p><p>we construct these two closed-loop transfer functions as <code>gr</code> and <code>gs</code> as follows.</p><pre><code class="language-julia"># PI controller transfer function
pic = PIController(1.0, 2.0)
gc = TransferFunction(pic)

# process, sensor dynamics
gu = 2 / (4 * s + 1) * exp(-0.5 * s)
gm = 1 / (s + 1) * exp(-0.1 * s)
gd = 6 / (6 * s + 1)

# open-loop transfer function
g_ol = gc * gu * gm

# closed-loop transfer function for regulator response
gr = ClosedLoopTransferFunction(gd, g_ol)

# closed-loop transfer function for servo response
gs = ClosedLoopTransferFunction(g_ol, g_ol)</code></pre><h2 id="detailed-docs"><a class="docs-heading-anchor" href="#detailed-docs">detailed docs</a><a id="detailed-docs-1"></a><a class="docs-heading-anchor-permalink" href="#detailed-docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Controlz.TransferFunction" href="#Controlz.TransferFunction"><code>Controlz.TransferFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">tf = TransferFunction([1, 2], [3, 5, 8])
tf = TransferFunction([1, 2], [3, 5, 8], 3.0)</code></pre><p>Construct a transfer function representing a linear, time-invariant system.</p><p><strong>Example</strong></p><p>to construct the transfer function</p><p class="math-container">\[G(s) = \frac{4e^{-2.2s}}{2s+1}\]</p><p>in Julia:</p><pre><code class="language-julia">tf = TransferFunction([4], [2, 1], 2.2)</code></pre><p><strong>Attributes</strong></p><ul><li><code>numerator::Poly</code>: the polynomial in the numerator of the transfer function</li><li><code>denominator::Poly</code>: the polynomial in the denominator of the transfer function</li><li><code>time_delay::Float64</code>: the associated time delay</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.ClosedLoopTransferFunction" href="#Controlz.ClosedLoopTransferFunction"><code>Controlz.ClosedLoopTransferFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>a closed-loop transfer function that relates an output <code>Y</code> and an input <code>U</code> in a feedback loop.</p><p>the resulting closed-loop transfer function is:</p><pre><code class="language-none"> Y      top
--- = --------
 U    1 + g_ol</code></pre><p><strong>example</strong></p><pre><code class="language-julia">g_ol = 4 / (s + 1) * 2 / (s + 2)
top = 5 / (s + 4)
g = ClosedLoopTransferFunction(top, g_ol)</code></pre><p><strong>Arguments</strong></p><ul><li><code>top::TransferFunction</code>: numerator</li><li><code>g_ol::TransferFunction</code>: open-loop transfer function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/closed_loops.jl#L3-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.zero_frequency_gain" href="#Controlz.zero_frequency_gain"><code>Controlz.zero_frequency_gain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">K = zero_frequency_gain(tf)</code></pre><p>compute the (signed) zero frequency gain of a transfer function <span>$g(s)$</span>, which is:</p><p class="math-container">\[K := \lim_{s\rightarrow 0} G(s)\]</p><p>the zero-frequency gain &quot;represents the ratio of the steady state value of the output with respect to a step input&quot; <a href="http://www.cds.caltech.edu/~murray/books/AM05/pdf/am06-xferfcns_16Sep06.pdf">source</a></p><p><strong>example</strong></p><pre><code class="language-julia">g = 5 / (3 * s + 1)
K = zero_frequency_gain(g) # K = 5.0</code></pre><p><strong>arguments</strong></p><ul><li><code>tf::TransferFunction</code>: the transfer function</li></ul><p><strong>returns</strong></p><ul><li><code>K::Float64</code>: the zero-frequency gain of the transfer function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L155-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.zeros_poles_gain" href="#Controlz.zeros_poles_gain"><code>Controlz.zeros_poles_gain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">z, p, gain = zeros_poles_gain(tf)</code></pre><p>Compute the zeros, poles, and zero-frequency gain of a transfer function.</p><ul><li>the zeros are the zeros of the numerator of the transfer function.</li><li>the poles are the zeros of the denominator of the transfer function.</li><li>the zero-frequency gain is the transfer function evaluated at <span>$s=0$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L221-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.zeros_poles_k" href="#Controlz.zeros_poles_k"><code>Controlz.zeros_poles_k</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"># compute the zeros, poles, and k-factor of a transfer function
z, p, k = zeros_poles_k(tf)
# construct a transfer function from its zeros, poles, and k-factor
tf = zeros_poles_k(z, p, k, time_delay=0.0)</code></pre><p>the representation of a transfer function in this context is:</p><p class="math-container">\[g(s)=k\dfrac{\Pi_j (s-z_j)}{\Pi_j (s-p_j)}\]</p><p>where <span>$z_j$</span> is zero <span>$j$</span>, <span>$p_j$</span> is pole <span>$j$</span>, and <span>$k$</span> is a constant factor (not equal to the zero-frequency gain) that uniquely specifies the transfer function.</p><ul><li>the zeros are the zeros of the numerator of the transfer function.</li><li>the poles are the zeros of the denominator of the transfer function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L184-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.pole_zero_cancellation" href="#Controlz.pole_zero_cancellation"><code>Controlz.pole_zero_cancellation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tf = pole_zero_cancellation(tf, verbose=false)</code></pre><p>find pairs of identical poles and zeros and return a new transfer function with the appropriate poles and zeros cancelled.  this is achieved by comparing the poles and zeros with <code>isapprox</code> and canceling if e.g., a pole is equal to a zero.</p><p><strong>Arguments</strong></p><ul><li><code>tf::TransferFunction</code>: the transfer function</li><li><code>verbose::Bool=false</code>: print off which poles, zeros are cancelled.</li></ul><p><strong>Example</strong></p><pre><code class="language-none">pole_zero_cancellation(s * (s - 1) / (s * (s + 1))) # (s-1)/(s+1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L263-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.evaluate" href="#Controlz.evaluate"><code>Controlz.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evaluate(tf, z)</code></pre><p>Evaluate a <code>TransferFunction</code>, <code>tf</code>, at a particular number <code>z</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">tf = TransferFunction([1], [3, 1])
evaluate(tf, 1.0) # 0.25
evaluate(tf, 2.0 + 3.0im) # also takes imaginary numbers as input</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L232-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.proper" href="#Controlz.proper"><code>Controlz.proper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">proper(tf)</code></pre><p>Return <code>true</code> if transfer function <code>tf</code> is proper and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.strictly_proper" href="#Controlz.strictly_proper"><code>Controlz.strictly_proper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">strictly_proper(tf)</code></pre><p>Return <code>true</code> if transfer function <code>tf</code> is strictly proper and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.characteristic_polynomial" href="#Controlz.characteristic_polynomial"><code>Controlz.characteristic_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">p = characteristic_polynomial(g_ol)</code></pre><p>Determine the characteristic polynomial associated with open loop transfer function <code>g_ol</code>.</p><p>The characteristic polynomial is <span>$1+g_{ol}(s)$</span>. The roots of the characteristic polynomial determine the character of the response of the closed loop system to bounded inputs.</p><p><strong>Arguments</strong></p><ul><li><code>g_ol::TransferFunction</code>: open loop transfer function</li></ul><p><strong>Returns</strong></p><p>a polynomial of type <code>Poly</code></p><p><strong>Example</strong></p><pre><code class="language-none">g_ol = 4 / (s + 3) / (s + 2) / (s + 1)
characteristic_polynomial(g_ol) # s³ + 6s² + 11s + 10, a `Poly`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/systems.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.zpk_form" href="#Controlz.zpk_form"><code>Controlz.zpk_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tf = zpk_form(tf)</code></pre><p>write transfer function <code>tf</code> in zeros, poles, k-factor form:</p><p class="math-container">\[g(s)=k\dfrac{\Pi_j (s-z_j)}{\Pi_j (s-p_j)}\]</p><p>where <span>$z_j$</span> is zero <span>$j$</span>, <span>$p_j$</span> is pole <span>$j$</span>, and <span>$k$</span> is a constant factor (not equal to the zero-frequency gain) that uniquely specifies the transfer function.</p><p>this is achieved by multiplying by 1.0 in a fancy way such that the highest power of <span>$s$</span> in the denominator is associated with a coefficient of <span>$1$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia">g = 8.0 / (2 * s^2 + 3 * s + 4)
g_zpk = zpk_form(g) # 4 / (s^2 + 1.5 s + 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L116-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.system_order" href="#Controlz.system_order"><code>Controlz.system_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">o = system_order(tf::TransferFunction)</code></pre><p>return the order of the numerator and denominator of the transfer function <code>tf</code>.</p><p>use <a href="#Controlz.pole_zero_cancellation"><code>pole_zero_cancellation</code></a> first if you wish to cancel poles and zeros that are equal before determining the order.</p><p><strong>returns</strong></p><p><code>o::Tuple{Int, Int}</code>: (order of numerator, order of denominator)</p><p><strong>examples</strong></p><pre><code class="language-julia">g = 1 / (s + 1)
system_order(g) # (0, 1)

g = (s + 1) / ((s + 2) * (s + 3))
system_order(g) # (1, 2)</code></pre><p>where <code>pole_zero_cancellation</code> is necessary: ``julia g = (s + 1) / (s + 1) ^ 2 system_order(g) # (1, 2)</p><p>g = pole<em>zero</em>cancellation(g) # 1 / (s + 1) system_order(g) # (0, 1) ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/tf.jl#L311-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.first_order_system" href="#Controlz.first_order_system"><code>Controlz.first_order_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">g = first_order_system(K, τ)</code></pre><p>construct a first-order transfer function with gain <code>K</code> and time constant <code>τ</code>:</p><p class="math-container">\[g(s)=\frac{K}{\tau s+1}\]</p><p><strong>example</strong></p><pre><code class="language-julia">K = 1.0
τ = 3.0
g = first_order_system(K, τ) # 1 / (3 * s + 1)</code></pre><p><strong>returns</strong></p><ul><li><code>g::TransferFunction</code>: the first order transfer function. well, (0, 1) order.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/special_tfs.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.second_order_system" href="#Controlz.second_order_system"><code>Controlz.second_order_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">g = second_order_system(K, τ, ξ)</code></pre><p>construct a second-order transfer function with gain <code>K</code>, time constant <code>τ</code>, and damping coefficient <code>ξ</code>:</p><p class="math-container">\[g(s)=\frac{K}{\tau^2 s^2 + 2\tau \xi s +1}\]</p><p><strong>example</strong></p><pre><code class="language-julia">K = 1.0
τ = 2.0
ξ = 0.1
g = second_order_system(K, τ, ξ) # 1 / (4 * s^2 + 0.4 * s + 1)</code></pre><p><strong>returns</strong></p><ul><li><code>g::TransferFunction</code>: the second order transfer function. well, (0, 2) order.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/special_tfs.jl#L20-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.time_constant" href="#Controlz.time_constant"><code>Controlz.time_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">τ = time_constant(g)</code></pre><p>compute the time constant τ of an order (0, 1) or order (0, 2) transfer function.</p><p>order (0, 1) representation:</p><p class="math-container">\[g(s)=\frac{K}{\tau s+1}\]</p><p>order (0, 2) representation:</p><p class="math-container">\[g(s)=\frac{K}{\tau^2 s^2 + 2\tau \xi s +1}\]</p><p><strong>returns</strong></p><p><code>τ::Float64</code>: the time constant.</p><p><strong>examples</strong></p><pre><code class="language-julia">g = 4 / (6 * s + 2)
time_constant(g) # 3.0

g = 1.0 / (8 * s^2 + 0.8 * s + 2)
time_constant(g) # 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/special_tfs.jl#L40-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.damping_coefficient" href="#Controlz.damping_coefficient"><code>Controlz.damping_coefficient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ξ = damping_coefficient(g)</code></pre><p>compute the damping coefficient ξ of an order (0, 2) transfer function.</p><p>order (0, 2) representation:</p><p class="math-container">\[g(s)=\frac{K}{\tau^2 s^2 + 2\tau \xi s +1}\]</p><p><strong>returns</strong></p><p><code>ξ::Float64</code>: the damping coefficient</p><p><strong>examples</strong></p><pre><code class="language-julia">g = 1.0 / (8 * s^2 + 0.8 * s + 2)
damping_coefficient(g) # 0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/special_tfs.jl#L77-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Controlz.gain_phase_margins" href="#Controlz.gain_phase_margins"><code>Controlz.gain_phase_margins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">margins = gain_phase_margins(g_ol, ω_c_guess=0.001, ω_g_guess=0.001)</code></pre><p>compute critical frequency (radians / time), gain crossover frequency (radians / time),  gain margin, and phase margin (radians) of a closed loop, given its closed loop transfer function <code>g_ol::TransferFunction</code>.</p><p>if ω<em>c or ω</em>g is not found (i.e. if either are <code>NaN</code>), but the <code>bode_plot</code> clearly shows  a critical/gain crossover frequency, adjust <code>ω_c_guess</code> or <code>ω_g_guess</code> to find the root.</p><p><strong>Example</strong></p><pre><code class="language-none">g_ol = 2 * exp(-s) / (5 * s + 1)
margins = gain_phase_margins(g_ol)
margins.ω_c # critical freq. (radians / time)
margins.ω_g # gain crossover freq. (radians / time)
margins.gain_margin # gain margin
margins.phase_margin # phase margin (radians)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/9be92928dc8d9008e431be65cc9d22734ecf004a/src/margins.jl#L12-L31">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Controlz</a><a class="docs-footer-nextpage" href="../sim/">Simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 20 May 2021 22:52">Thursday 20 May 2021</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
