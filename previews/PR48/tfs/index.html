<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transfer Functions · Controlz.jl</title><meta name="title" content="Transfer Functions · Controlz.jl"/><meta property="og:title" content="Transfer Functions · Controlz.jl"/><meta property="twitter:title" content="Transfer Functions · Controlz.jl"/><meta name="description" content="Documentation for Controlz.jl."/><meta property="og:description" content="Documentation for Controlz.jl."/><meta property="twitter:description" content="Documentation for Controlz.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/flux.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Controlz.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Controlz.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Controlz</a></li><li class="is-active"><a class="tocitem" href>Transfer Functions</a><ul class="internal"><li><a class="tocitem" href="#constructing-a-transfer-function"><span>constructing a transfer function</span></a></li><li><a class="tocitem" href="#accessing-attributes-of-a-transfer-function"><span>accessing attributes of a transfer function</span></a></li><li><a class="tocitem" href="#time-delays"><span>time delays</span></a></li><li><a class="tocitem" href="#zeros,-poles,-k-factor-representation"><span>zeros, poles, k-factor representation</span></a></li><li><a class="tocitem" href="#transfer-function-algebra"><span>transfer function algebra</span></a></li><li><a class="tocitem" href="#evaluate-a-transfer-function-at-a-complex-number"><span>evaluate a transfer function at a complex number</span></a></li><li><a class="tocitem" href="#zero-frequency-gain-of-a-transfer-function"><span>zero-frequency gain of a transfer function</span></a></li><li><a class="tocitem" href="#poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function"><span>poles, zeros, and zero-frequency gain of a transfer function</span></a></li><li><a class="tocitem" href="#cancel-poles-and-zeros"><span>cancel poles and zeros</span></a></li><li><a class="tocitem" href="#the-order-of-a-transfer-function"><span>the order of a transfer function</span></a></li><li><a class="tocitem" href="#frequency-response-of-an-open-loop-transfer-function"><span>frequency response of an open-loop transfer function</span></a></li><li><a class="tocitem" href="#special-transfer-functions"><span>special transfer functions</span></a></li><li><a class="tocitem" href="#closed-loop-transfer-functions"><span>closed-loop transfer functions</span></a></li><li><a class="tocitem" href="#detailed-docs"><span>detailed docs</span></a></li></ul></li><li><a class="tocitem" href="../sim/">Simulation</a></li><li><a class="tocitem" href="../viz/">Visualization</a></li><li><a class="tocitem" href="../controls/">Control systems</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Transfer Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Transfer Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SimonEnsemble/Controlz.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SimonEnsemble/Controlz.jl/blob/main/docs/src/tfs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="transfer-functions"><a class="docs-heading-anchor" href="#transfer-functions">transfer functions</a><a id="transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#transfer-functions" title="Permalink"></a></h1><p>consider the linear, time-invariant system:</p><p><img src="../assets/simple_input_output.png" alt/></p><p>with:</p><ul><li>input <span>$U(s)=\mathcal{L}[u(t)]$</span></li><li>output <span>$Y(s)=\mathcal{L}[y(t)]$</span></li></ul><p>the output for an input is characterized by a transfer function <span>$g(s)=Y(s)/U(s)$</span>.</p><p>here, <span>$\mathcal{L}[\cdot]$</span> is the Laplace transform that maps a function in the time domain <span>$t\in\mathbb{R}$</span> into the frequency domain <span>$s\in\mathbb{C}$</span>.</p><p>a data structure, <code>TransferFunction</code>, represents a transfer function. </p><h2 id="constructing-a-transfer-function"><a class="docs-heading-anchor" href="#constructing-a-transfer-function">constructing a transfer function</a><a id="constructing-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#constructing-a-transfer-function" title="Permalink"></a></h2><p>for example, consider the transfer function <span>$g(s)=\dfrac{5s+1}{s^2 + 4s+5}$</span>.</p><p><em>constructor 1.</em> we can construct <span>$g(s)$</span> in an intuitive way that resembles the algebraic expression:</p><pre><code class="language-julia hljs">g = (5 * s + 1) / (s ^ 2 + 4 * s + 5) # construction method 1
# output
     5.0*s + 1.0
---------------------
1.0*s^2 + 4.0*s + 5.0</code></pre><p><em>constructor 2.</em> alternatively, we can construct a <code>TransferFunction</code> using the coefficients associated with the powers of <span>$s$</span> in the polynomials composing the numerator and denominator, respectively, of the rational function <span>$g(s)$</span>. coefficients of the highest powers of <span>$s$</span> are listed first.</p><pre><code class="language-julia hljs">g = TransferFunction([5, 1], [1, 4, 5]) # construction method 2</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>under the hood, <code>s == TransferFunction([1, 0], [1])</code>.</p></div></div><h2 id="accessing-attributes-of-a-transfer-function"><a class="docs-heading-anchor" href="#accessing-attributes-of-a-transfer-function">accessing attributes of a transfer function</a><a id="accessing-attributes-of-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#accessing-attributes-of-a-transfer-function" title="Permalink"></a></h2><p>as rational functions associated with a time delay, each <code>TransferFunction</code> data structure has a <code>numerator</code>, <code>denominator</code>, and <code>time_delay</code> attribute. access as follows:</p><pre><code class="language-julia hljs">g.numerator
# output
Polynomial(1.0 + 5.0*s)</code></pre><pre><code class="language-julia hljs">g.denominator
# output
Polynomial(5.0 + 4.0*s + 1.0*s^2)</code></pre><pre><code class="language-julia hljs">g.time_delay
# output
0.0</code></pre><p><code>g.numerator</code> and <code>g.denominator</code> are <code>Polynomial</code>s from <a href="https://github.com/JuliaMath/Polynomials.jl">Polynomials.jl</a>.</p><h2 id="time-delays"><a class="docs-heading-anchor" href="#time-delays">time delays</a><a id="time-delays-1"></a><a class="docs-heading-anchor-permalink" href="#time-delays" title="Permalink"></a></h2><p>to construct a transfer function with a time delay, such as <span>$g(s)=\dfrac{3}{2s+1}e^{-2s}$</span>...</p><pre><code class="language-julia hljs">θ = 2.0                              # time delay
g = 3 / (2 * s + 1) * exp(-θ * s)    # construction method 1
g = TransferFunction([3], [2, 1], θ) # construction method 2
# output
    3.0
----------- e^(-2.0*s)
2.0*s + 1.0</code></pre><h2 id="zeros,-poles,-k-factor-representation"><a class="docs-heading-anchor" href="#zeros,-poles,-k-factor-representation">zeros, poles, k-factor representation</a><a id="zeros,-poles,-k-factor-representation-1"></a><a class="docs-heading-anchor-permalink" href="#zeros,-poles,-k-factor-representation" title="Permalink"></a></h2><p>we can write any transfer function <span>$g(s)$</span> in terms of its poles (<span>$p_j$</span>), zeros (<span>$z_j$</span>), k-factor (<span>$k$</span>), and time delay (<span>$\theta$</span>):</p><p class="math-container">\[g(s)=k\dfrac{\Pi_j (s-z_j)}{\Pi_j(s-p_j)}e^{-\theta s}\]</p><p>the scalar factor <span>$k$</span> allows us to uniquely specify a transfer function in terms of its poles, zeros, and time delay. note that the <span>$k$</span>-factor is not equal to the zero-frequency gain.</p><p>for example, consider:</p><p class="math-container">\[g(s)=\dfrac{5s+1}{s^2 + 4s+5}=5\dfrac{(s+1/5)}{(s+2+i)(s+2-i)}\]</p><h4 id="constructing-a-transfer-function-from-its-zeros,-poles-and-k-factor"><a class="docs-heading-anchor" href="#constructing-a-transfer-function-from-its-zeros,-poles-and-k-factor">constructing a transfer function from its zeros, poles and k-factor</a><a id="constructing-a-transfer-function-from-its-zeros,-poles-and-k-factor-1"></a><a class="docs-heading-anchor-permalink" href="#constructing-a-transfer-function-from-its-zeros,-poles-and-k-factor" title="Permalink"></a></h4><pre><code class="language-julia hljs">g = zeros_poles_k([-1/5], [-2 + im, -2 - im], 5.0, time_delay=0.0)  # construction method 3
# output
     5.0*s + 1.0
---------------------
1.0*s^2 + 4.0*s + 5.0</code></pre><p><code>im</code> is the imaginary number <span>$i$</span>. see the <a href="https://docs.julialang.org/en/v1/manual/complex-and-rational-numbers/">Julia docs on complex numbers</a>.</p><h4 id="computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function"><a class="docs-heading-anchor" href="#computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function">computing the poles, zeros, and k-factor of a transfer function</a><a id="computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#computing-the-poles,-zeros,-and-k-factor-of-a-transfer-function" title="Permalink"></a></h4><pre><code class="language-julia hljs">g = (5 * s + 1) / (s ^ 2 + 4 * s + 5)
z, p, k = zeros_poles_k(g)
# output
([-0.2], ComplexF64[-2.0 - 1.0im, -2.0 + 1.0im], 5.0)</code></pre><h2 id="transfer-function-algebra"><a class="docs-heading-anchor" href="#transfer-function-algebra">transfer function algebra</a><a id="transfer-function-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#transfer-function-algebra" title="Permalink"></a></h2><p>add <code>+</code>, subject <code>-</code>, multiply <code>*</code>, and divide <code>/</code> transfer functions.</p><pre><code class="language-julia hljs">g₁ = 3 / (s + 2)
g₂ = 1 / (s + 4)
g_product = g₁ * g₂
# output
         3.0
---------------------
1.0*s^2 + 6.0*s + 8.0</code></pre><pre><code class="language-julia hljs">g_sum = g₁ + g₂
# output
    4.0*s + 14.0
---------------------
1.0*s^2 + 6.0*s + 8.0</code></pre><h2 id="evaluate-a-transfer-function-at-a-complex-number"><a class="docs-heading-anchor" href="#evaluate-a-transfer-function-at-a-complex-number">evaluate a transfer function at a complex number</a><a id="evaluate-a-transfer-function-at-a-complex-number-1"></a><a class="docs-heading-anchor-permalink" href="#evaluate-a-transfer-function-at-a-complex-number" title="Permalink"></a></h2><p>for example, to evaluate <span>$g(s)=\dfrac{4}{s+2}$</span> at <span>$s=-2+i$</span>:</p><pre><code class="language-julia hljs">g = 4 / (s + 2)
evaluate(g, - 2 + im)
# output
0.0 - 4.0im</code></pre><h2 id="zero-frequency-gain-of-a-transfer-function"><a class="docs-heading-anchor" href="#zero-frequency-gain-of-a-transfer-function">zero-frequency gain of a transfer function</a><a id="zero-frequency-gain-of-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#zero-frequency-gain-of-a-transfer-function" title="Permalink"></a></h2><p>compute the zero-frequency gain of a transfer function <span>$g(s)$</span>, which is <span>$g(s)$</span> evaluated at <span>$s=0$</span>, as follows:</p><pre><code class="language-julia hljs">g = (5 * s + 1) / (s ^ 2 + 4 * s + 5)
zero_frequency_gain(g)
# output
0.2</code></pre><p>the zero-frequency gain is the ratio of the steady state output value to the steady state input value (e.g., consider a step input). note that the zero-frequency gain could be infinite or zero, which is why we do not have a function to construct a transfer function from its zeros, poles, and <em>zero-frequency gain</em>.</p><h2 id="poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function"><a class="docs-heading-anchor" href="#poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function">poles, zeros, and zero-frequency gain of a transfer function</a><a id="poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#poles,-zeros,-and-zero-frequency-gain-of-a-transfer-function" title="Permalink"></a></h2><p>compute the poles, zeros, and zero-frequency gain of a transfer function all at once as follows:</p><pre><code class="language-julia hljs">g = (5 * s + 5) / (s ^ 2 + 4 * s + 5)
z, p, gain = zeros_poles_gain(g)
# output
([-1.0], ComplexF64[-2.0 - 1.0im, -2.0 + 1.0im], 1.0)</code></pre><h2 id="cancel-poles-and-zeros"><a class="docs-heading-anchor" href="#cancel-poles-and-zeros">cancel poles and zeros</a><a id="cancel-poles-and-zeros-1"></a><a class="docs-heading-anchor-permalink" href="#cancel-poles-and-zeros" title="Permalink"></a></h2><p>cancel pairs of identical poles and zeros in a transfer function as follows:</p><pre><code class="language-julia hljs"># define g(s) = s * (s+1) / ((s+3) * s * (s+1) ^ 2)
g = TransferFunction([1, 1, 0], [1, 5, 7, 3, 0])
pole_zero_cancellation(g) # 1 / ((s+3) * (s+1))
# output
         1.0
---------------------
1.0*s^2 + 4.0*s + 3.0</code></pre><p>under the hood, <code>pole_zero_cancellation</code> compares all pairs of poles and zeros to look for identical pairs via <code>isapprox</code>. after removing identical pole-zero pairs, we reconstruct the transfer function from the remaining poles and zeros–-in addition to its k-factor. we ensure that the coefficients in the resulting rational function are real.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>pole-zero cancellation is done automatically when multiplying, dividing, adding, and subtracting transfer functions, as illustrated below.</p></div></div><pre><code class="language-julia hljs">g = s * (s+1) / ((s+3) * s * (s+1) ^ 2)
# output
         1.0
---------------------
1.0*s^2 + 4.0*s + 3.0</code></pre><h2 id="the-order-of-a-transfer-function"><a class="docs-heading-anchor" href="#the-order-of-a-transfer-function">the order of a transfer function</a><a id="the-order-of-a-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#the-order-of-a-transfer-function" title="Permalink"></a></h2><p>we can find the <em>apparent</em> order of the polynomials in the numerator and denominator of the rational function comprising the transfer function:</p><pre><code class="language-julia hljs">g = (s + 1) / ((s + 2) * (s + 3))
system_order(g)
# output
(1, 2)</code></pre><h2 id="frequency-response-of-an-open-loop-transfer-function"><a class="docs-heading-anchor" href="#frequency-response-of-an-open-loop-transfer-function">frequency response of an open-loop transfer function</a><a id="frequency-response-of-an-open-loop-transfer-function-1"></a><a class="docs-heading-anchor-permalink" href="#frequency-response-of-an-open-loop-transfer-function" title="Permalink"></a></h2><p>in the closed loop below, <span>$Y_{sp}$</span> is the set point for the output, <span>$E$</span> is the error, and <span>$Y_m$</span> is the measurement of the output.</p><p><img src="../assets/gol.png" alt/></p><p>compute the critical frequency, gain crossover frequency, gain margin, and phase margin of a closed loop control system with open-loop transfer function <code>g_ol</code> with <code>gain_phase_margins</code>. for example, consider:</p><p class="math-container">\[g_{ol}(s)=\dfrac{2e^{-s}}{5s+1}\]</p><pre><code class="language-julia hljs">g_ol = 2 * exp(-s) / (5 * s + 1)
margins = gain_phase_margins(g_ol)
# output
-- gain/phase margin info--
	critical frequency ω_c [rad/time]:       1.68868
	gain crossover frequency ω_g [rad/time]: 0.34641
	gain margin:                             4.25121
	phase margin:                            1.74798</code></pre><p>access the attributes of <code>margins</code> via:</p><pre><code class="language-julia hljs">margins.ω_c          # critical freq. (radians / time)
margins.ω_g          # gain crossover freq. (radians / time)
margins.gain_margin  # gain margin
margins.phase_margin # phase margin (radians)</code></pre><h2 id="special-transfer-functions"><a class="docs-heading-anchor" href="#special-transfer-functions">special transfer functions</a><a id="special-transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#special-transfer-functions" title="Permalink"></a></h2><h3 id="(0,-1)-order-transfer-functions"><a class="docs-heading-anchor" href="#(0,-1)-order-transfer-functions">(0, 1) order transfer functions</a><a id="(0,-1)-order-transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#(0,-1)-order-transfer-functions" title="Permalink"></a></h3><p class="math-container">\[g(s)=\frac{K}{\tau s +1}\]</p><p>easily construct:</p><pre><code class="language-julia hljs">K = 2.0
τ = 3.0
g = first_order_system(K, τ)
# output
    2.0
-----------
3.0*s + 1.0</code></pre><p>compute time constant:</p><pre><code class="language-julia hljs">g = 10 / (6 * s + 2)
time_constant(g)
# output
3.0</code></pre><h3 id="(0,-2)-order-transfer-functions"><a class="docs-heading-anchor" href="#(0,-2)-order-transfer-functions">(0, 2) order transfer functions</a><a id="(0,-2)-order-transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#(0,-2)-order-transfer-functions" title="Permalink"></a></h3><p class="math-container">\[g(s)=\frac{K}{\tau^2 s^2 + 2\tau \xi s +1}\]</p><p>easily construct:</p><pre><code class="language-julia hljs">K = 1.0
τ = 2.0
ξ = 0.1
g = second_order_system(K, τ, ξ)
# output
         1.0
---------------------
4.0*s^2 + 0.4*s + 1.0</code></pre><p>compute time constant, damping coefficient:</p><pre><code class="language-julia hljs">τ = time_constant(g)
# output
2.0</code></pre><pre><code class="language-julia hljs">ξ = damping_coefficient(g)
# output
0.1</code></pre><h2 id="closed-loop-transfer-functions"><a class="docs-heading-anchor" href="#closed-loop-transfer-functions">closed-loop transfer functions</a><a id="closed-loop-transfer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#closed-loop-transfer-functions" title="Permalink"></a></h2><p>to represent a closed-loop transfer function, we use a special transfer function type, <code>ClosedLoopTransferFunction</code>. this is only necessary when time delays are involved, but it works for when time delays are <em>not</em> involved as well.</p><p><img src="../assets/full_feedback_control_system.png" alt/></p><p>using block diagram algebra, we find the closed-loop transfer functions that relate changes in the output <span>$y$</span> to changes in the set point <span>$y_{sp}$</span> and to changes in the disturbance <span>$d$</span>:</p><p class="math-container">\[g_r(s)=\dfrac{Y(s)}{D(s)}=\dfrac{g_d(s)}{1+g_c(s)g_u(s)g_m(s)}\]</p><p class="math-container">\[g_s(s)=\dfrac{Y(s)}{Y_{sp}(s)}=\dfrac{g_c(s)g_u(s)}{1+g_c(s)g_u(s)g_m(s)}\]</p><p>we construct these two closed-loop transfer functions as <code>gr</code> and <code>gs</code> as follows.</p><pre><code class="language-julia hljs"># PI controller transfer function
pic = PIController(1.0, 2.0)
gc = TransferFunction(pic)

# process, sensor dynamics
gu = 2 / (4 * s + 1) * exp(-0.5 * s)
gm = 1 / (s + 1) * exp(-0.1 * s)
gd = 6 / (6 * s + 1)

# open-loop transfer function
g_ol = gc * gu * gm

# closed-loop transfer function for regulator response
gr = ClosedLoopTransferFunction(gd, g_ol)
# output
closed-loop transfer function.
      top
    -------
    1 + g_ol

  top =
    6.0
-----------
6.0*s + 1.0

  g_ol =
       4.0*s + 2.0
-------------------------- e^(-0.6*s)
8.0*s^3 + 10.0*s^2 + 2.0*s</code></pre><pre><code class="language-julia hljs"># closed-loop transfer function for servo response
gs = ClosedLoopTransferFunction(gc * gu, g_ol)
# output
closed-loop transfer function.
      top
    -------
    1 + g_ol

  top =
  4.0*s + 2.0
--------------- e^(-0.5*s)
8.0*s^2 + 2.0*s

  g_ol =
       4.0*s + 2.0
-------------------------- e^(-0.6*s)
8.0*s^3 + 10.0*s^2 + 2.0*s</code></pre><h2 id="detailed-docs"><a class="docs-heading-anchor" href="#detailed-docs">detailed docs</a><a id="detailed-docs-1"></a><a class="docs-heading-anchor-permalink" href="#detailed-docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.TransferFunction" href="#Controlz.TransferFunction"><code>Controlz.TransferFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">tf = TransferFunction([1, 2], [3, 5, 8])
tf = TransferFunction([1, 2], [3, 5, 8], 3.0)</code></pre><p>construct a transfer function representing a linear, time-invariant system.</p><p><strong>example</strong></p><p>to construct the transfer function</p><p class="math-container">\[G(s) = \frac{4e^{-2.2s}}{2s+1}\]</p><p>in Julia:</p><pre><code class="language-julia hljs">tf = TransferFunction([4], [2, 1], 2.2)
# output
    4.0
----------- e^(-2.2*s)
2.0*s + 1.0</code></pre><p><strong>attributes</strong></p><ul><li><code>numerator::Polynomial{Float64, :s}</code>: the polynomial in the numerator of the transfer function</li><li><code>denominator::Polynomial{Float64, :s}</code>: the polynomial in the denominator of the transfer function</li><li><code>time_delay::Float64</code>: the associated time delay</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.ClosedLoopTransferFunction" href="#Controlz.ClosedLoopTransferFunction"><code>Controlz.ClosedLoopTransferFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>a closed-loop transfer function that relates an output <code>Y</code> and an input <code>U</code> in a feedback loop.</p><p>the resulting closed-loop transfer function is:</p><pre><code class="nohighlight hljs"> Y      top
--- = --------
 U    1 + g_ol</code></pre><p><strong>example</strong></p><pre><code class="language-julia hljs">g_ol = 4 / (s + 1) * 2 / (s + 2)
top = 5 / (s + 4)
g = ClosedLoopTransferFunction(top, g_ol)
# output
closed-loop transfer function.
      top
    -------
    1 + g_ol

  top =
    5.0
-----------
1.0*s + 4.0

  g_ol =
         8.0
---------------------
1.0*s^2 + 3.0*s + 2.0</code></pre><p><strong>attributes</strong></p><ul><li><code>top::TransferFunction</code>: numerator</li><li><code>g_ol::TransferFunction</code>: open-loop transfer function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/closed_loops.jl#L3-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.zero_frequency_gain" href="#Controlz.zero_frequency_gain"><code>Controlz.zero_frequency_gain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">K = zero_frequency_gain(tf)</code></pre><p>compute the (signed) zero frequency gain of a transfer function <span>$g(s)$</span>, which is:</p><p class="math-container">\[K := \lim_{s\rightarrow 0} G(s)\]</p><p>the zero-frequency gain &quot;represents the ratio of the steady state value of the output with respect to a step input&quot; <a href="http://www.cds.caltech.edu/~murray/books/AM05/pdf/am06-xferfcns_16Sep06.pdf">source</a></p><p><strong>example</strong></p><pre><code class="language-julia hljs">g = 5 / (3 * s + 1)
K = zero_frequency_gain(g)
# output
5.0</code></pre><p><strong>arguments</strong></p><ul><li><code>tf::TransferFunction</code>: the transfer function</li></ul><p><strong>returns</strong></p><ul><li><code>K::Float64</code>: the zero-frequency gain of the transfer function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L167-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.zeros_poles_gain" href="#Controlz.zeros_poles_gain"><code>Controlz.zeros_poles_gain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">z, p, gain = zeros_poles_gain(tf)</code></pre><p>Compute the zeros, poles, and zero-frequency gain of a transfer function.</p><ul><li>the zeros are the zeros of the numerator of the transfer function.</li><li>the poles are the zeros of the denominator of the transfer function.</li><li>the zero-frequency gain is the transfer function evaluated at <span>$s=0$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L233-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.zeros_poles_k" href="#Controlz.zeros_poles_k"><code>Controlz.zeros_poles_k</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"># compute the zeros, poles, and k-factor of a transfer function
z, p, k = zeros_poles_k(tf)
# construct a transfer function from its zeros, poles, and k-factor
tf = zeros_poles_k(z, p, k, time_delay=0.0)</code></pre><p>the representation of a transfer function in this context is:</p><p class="math-container">\[g(s)=k\dfrac{\Pi_j (s-z_j)}{\Pi_j (s-p_j)}\]</p><p>where <span>$z_j$</span> is zero <span>$j$</span>, <span>$p_j$</span> is pole <span>$j$</span>, and <span>$k$</span> is a constant factor (not equal to the zero-frequency gain) that uniquely specifies the transfer function.</p><ul><li>the zeros are the zeros of the numerator of the transfer function.</li><li>the poles are the zeros of the denominator of the transfer function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L198-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.pole_zero_cancellation" href="#Controlz.pole_zero_cancellation"><code>Controlz.pole_zero_cancellation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tf = pole_zero_cancellation(tf, verbose=false, digits=8)</code></pre><p>find (pole, zero) pairs such that pole = zero and return a new transfer function with those pairs cancelled. this is achieved by comparing the poles and zeros with <code>isapprox</code>, with poles and zeros rounded to  <code>digits</code> digits (also applies to reconstruction).</p><p><strong>arguments</strong></p><ul><li><code>tf::TransferFunction</code>: the transfer function</li><li><code>verbose::Bool=false</code>: print off which poles, zeros are cancelled.</li><li><code>digits::Int</code>: number of digits to round poles and zeros to, for (i) cancelling and (ii) reconstruction.</li></ul><p><strong>example</strong></p><pre><code class="language-julia hljs">pole_zero_cancellation(s * (s - 1) / (s * (s + 1)))
# output
1.0*s - 1.0
-----------
1.0*s + 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L276-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.evaluate" href="#Controlz.evaluate"><code>Controlz.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate(tf, z)</code></pre><p>evaluate a <code>TransferFunction</code>, <code>tf</code>, at a particular number <code>z</code> (could be complex).</p><p><strong>example</strong></p><pre><code class="language-julia hljs">tf = TransferFunction([1], [3, 1])
evaluate(tf, 1.0)
# output
0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L244-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.proper" href="#Controlz.proper"><code>Controlz.proper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">proper(tf)</code></pre><p>Return <code>true</code> if transfer function <code>tf</code> is proper and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.strictly_proper" href="#Controlz.strictly_proper"><code>Controlz.strictly_proper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strictly_proper(tf)</code></pre><p>Return <code>true</code> if transfer function <code>tf</code> is strictly proper and <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L268-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.characteristic_polynomial" href="#Controlz.characteristic_polynomial"><code>Controlz.characteristic_polynomial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">p = characteristic_polynomial(g_ol)</code></pre><p>Determine the characteristic polynomial associated with open loop transfer function <code>g_ol</code>.</p><p>The characteristic polynomial is <span>$1+g_{ol}(s)$</span>. The roots of the characteristic polynomial determine the character of the response of the closed loop system to bounded inputs.</p><p><strong>Arguments</strong></p><ul><li><code>g_ol::TransferFunction</code>: open loop transfer function</li></ul><p><strong>Returns</strong></p><p>a polynomial of type <code>Polynomial</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g_ol = 4 / (s + 3) / (s + 2) / (s + 1)
characteristic_polynomial(g_ol)
# output
Polynomial(10.0 + 11.0*s + 6.0*s^2 + 1.0*s^3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/systems.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.zpk_form" href="#Controlz.zpk_form"><code>Controlz.zpk_form</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tf = zpk_form(tf)</code></pre><p>write transfer function <code>tf</code> in zeros, poles, k-factor form:</p><p class="math-container">\[g(s)=k\dfrac{\Pi_j (s-z_j)}{\Pi_j (s-p_j)}\]</p><p>where <span>$z_j$</span> is zero <span>$j$</span>, <span>$p_j$</span> is pole <span>$j$</span>, and <span>$k$</span> is a constant factor (not equal to the zero-frequency gain) that uniquely specifies the transfer function.</p><p>this is achieved by multiplying by 1.0 in a fancy way such that the highest power of <span>$s$</span> in the denominator is associated with a coefficient of <span>$1$</span>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g = 8.0 / (2 * s^2 + 3 * s + 4)
g_zpk = zpk_form(g)
# output
         4.0
---------------------
1.0*s^2 + 1.5*s + 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L123-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.system_order" href="#Controlz.system_order"><code>Controlz.system_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">o = system_order(tf::TransferFunction)</code></pre><p>return the order of the numerator and denominator of the transfer function <code>tf</code>.</p><p>use <a href="#Controlz.pole_zero_cancellation"><code>pole_zero_cancellation</code></a> first if you wish to cancel poles and zeros that are equal before determining the order.</p><p><strong>returns</strong></p><p><code>o::Tuple{Int, Int}</code>: (order of numerator, order of denominator)</p><p><strong>examples</strong></p><pre><code class="language-julia hljs">g = 1 / (s + 1)
system_order(g)
# output 
(0, 1)

g = (s + 1) / ((s + 2) * (s + 3))
system_order(g)
# output
(1, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/tf.jl#L332-L354">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.first_order_system" href="#Controlz.first_order_system"><code>Controlz.first_order_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">g = first_order_system(K, τ)</code></pre><p>construct a first-order transfer function with gain <code>K</code> and time constant <code>τ</code>:</p><p class="math-container">\[g(s)=\frac{K}{\tau s+1}\]</p><p><strong>example</strong></p><pre><code class="language-julia hljs">K = 1.0
τ = 3.0
g = first_order_system(K, τ)
# output
    1.0
-----------
3.0*s + 1.0</code></pre><p><strong>returns</strong></p><ul><li><code>g::TransferFunction</code>: the first order transfer function. well, (0, 1) order.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/special_tfs.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.second_order_system" href="#Controlz.second_order_system"><code>Controlz.second_order_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">g = second_order_system(K, τ, ξ)</code></pre><p>construct a second-order transfer function with gain <code>K</code>, time constant <code>τ</code>, and damping coefficient <code>ξ</code>:</p><p class="math-container">\[g(s)=\frac{K}{\tau^2 s^2 + 2\tau \xi s +1}\]</p><p><strong>example</strong></p><pre><code class="language-julia hljs">K = 1.0
τ = 2.0
ξ = 0.1
g = second_order_system(K, τ, ξ)
# output
         1.0
---------------------
4.0*s^2 + 0.4*s + 1.0</code></pre><p><strong>returns</strong></p><ul><li><code>g::TransferFunction</code>: the second order transfer function. well, (0, 2) order.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/special_tfs.jl#L24-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.time_constant" href="#Controlz.time_constant"><code>Controlz.time_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">τ = time_constant(g)</code></pre><p>compute the time constant τ of an order (0, 1) or order (0, 2) transfer function.</p><p>order (0, 1) representation:</p><p class="math-container">\[g(s)=\frac{K}{\tau s+1}\]</p><p>order (0, 2) representation:</p><p class="math-container">\[g(s)=\frac{K}{\tau^2 s^2 + 2\tau \xi s +1}\]</p><p><strong>returns</strong></p><p><code>τ::Float64</code>: the time constant.</p><p><strong>examples</strong></p><pre><code class="language-julia hljs">g = 4 / (6 * s + 2)
time_constant(g)
# output 
3.0

g = 1.0 / (8 * s^2 + 0.8 * s + 2)
time_constant(g) 
# output
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/special_tfs.jl#L48-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.damping_coefficient" href="#Controlz.damping_coefficient"><code>Controlz.damping_coefficient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ξ = damping_coefficient(g)</code></pre><p>compute the damping coefficient ξ of an order (0, 2) transfer function.</p><p>order (0, 2) representation:</p><p class="math-container">\[g(s)=\frac{K}{\tau^2 s^2 + 2\tau \xi s +1}\]</p><p><strong>returns</strong></p><p><code>ξ::Float64</code>: the damping coefficient</p><p><strong>examples</strong></p><pre><code class="language-julia hljs">g = 1.0 / (8 * s^2 + 0.8 * s + 2)
damping_coefficient(g)
# output
0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/special_tfs.jl#L90-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Controlz.gain_phase_margins" href="#Controlz.gain_phase_margins"><code>Controlz.gain_phase_margins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">margins = gain_phase_margins(g_ol, ω_c_guess=0.001, ω_g_guess=0.001)</code></pre><p>compute critical frequency (radians / time), gain crossover frequency (radians / time),  gain margin, and phase margin (radians) of a closed loop, given its closed loop transfer function <code>g_ol::TransferFunction</code>.</p><p>if ω<em>c or ω</em>g is not found (i.e. if either are <code>NaN</code>), but the <code>bode_plot</code> clearly shows  a critical/gain crossover frequency, adjust <code>ω_c_guess</code> or <code>ω_g_guess</code> to find the root.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">g_ol = 2 * exp(-s) / (5 * s + 1)
margins = gain_phase_margins(g_ol)
margins.ω_c # critical freq. (radians / time)
margins.ω_g # gain crossover freq. (radians / time)
margins.gain_margin # gain margin
margins.phase_margin # phase margin (radians)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SimonEnsemble/Controlz.jl/blob/90312a18e6fcebf40e3f376d36bbbb521fb42503/src/margins.jl#L12-L31">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Controlz</a><a class="docs-footer-nextpage" href="../sim/">Simulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 8 February 2024 03:20">Thursday 8 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
